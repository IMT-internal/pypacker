<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pypacker Package &mdash; Pypacker 3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Pypacker 3.0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">Pypacker 3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pypacker-package">
<h1>pypacker Package<a class="headerlink" href="#pypacker-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-pypacker.checksum">
<span id="checksum-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">checksum</span></tt> Module<a class="headerlink" href="#module-pypacker.checksum" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pypacker.checksum.crc32_add">
<tt class="descclassname">pypacker.checksum.</tt><tt class="descname">crc32_add</tt><big>(</big><em>crc</em>, <em>buf</em><big>)</big><a class="headerlink" href="#pypacker.checksum.crc32_add" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pypacker.checksum.crc32_cksum">
<tt class="descclassname">pypacker.checksum.</tt><tt class="descname">crc32_cksum</tt><big>(</big><em>buf</em><big>)</big><a class="headerlink" href="#pypacker.checksum.crc32_cksum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return computed CRC-32c checksum.</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.checksum.crc32_done">
<tt class="descclassname">pypacker.checksum.</tt><tt class="descname">crc32_done</tt><big>(</big><em>crc</em><big>)</big><a class="headerlink" href="#pypacker.checksum.crc32_done" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pypacker.checksum.in_cksum">
<tt class="descclassname">pypacker.checksum.</tt><tt class="descname">in_cksum</tt><big>(</big><em>buf</em><big>)</big><a class="headerlink" href="#pypacker.checksum.in_cksum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return computed Internet Protocol checksum.</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.checksum.in_cksum_add">
<tt class="descclassname">pypacker.checksum.</tt><tt class="descname">in_cksum_add</tt><big>(</big><em>s</em>, <em>buf</em><big>)</big><a class="headerlink" href="#pypacker.checksum.in_cksum_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add checksum value to the given value s.</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.checksum.in_cksum_done">
<tt class="descclassname">pypacker.checksum.</tt><tt class="descname">in_cksum_done</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#pypacker.checksum.in_cksum_done" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete checksum building.</p>
</dd></dl>

</div>
<div class="section" id="gzip-module">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">gzip</span></tt> Module<a class="headerlink" href="#gzip-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pypacker.ppcap">
<span id="ppcap-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">ppcap</span></tt> Module<a class="headerlink" href="#module-pypacker.ppcap" title="Permalink to this headline">¶</a></h2>
<p>Packet read and write routines for pcap format.
See <a class="reference external" href="http://wiki.wireshark.org/Development/LibpcapFileFormat">http://wiki.wireshark.org/Development/LibpcapFileFormat</a></p>
<dl class="class">
<dt id="pypacker.ppcap.FileHdr">
<em class="property">class </em><tt class="descclassname">pypacker.ppcap.</tt><tt class="descname">FileHdr</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pypacker.ppcap.FileHdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypacker.pypacker.Packet" title="pypacker.pypacker.Packet"><tt class="xref py py-class docutils literal"><span class="pre">pypacker.pypacker.Packet</span></tt></a></p>
<p>pcap file header.</p>
<dl class="attribute">
<dt id="pypacker.ppcap.FileHdr.__hdr__">
<tt class="descname">__hdr__</tt><em class="property"> = (('magic', 'I', 2712847316), ('v_major', 'H', 2), ('v_minor', 'H', 4), ('thiszone', 'I', 0), ('sigfigs', 'I', 0), ('snaplen', 'I', 1500), ('linktype', 'I', 1))</em><a class="headerlink" href="#pypacker.ppcap.FileHdr.__hdr__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.FileHdr.linktype">
<tt class="descname">linktype</tt><a class="headerlink" href="#pypacker.ppcap.FileHdr.linktype" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.FileHdr.magic">
<tt class="descname">magic</tt><a class="headerlink" href="#pypacker.ppcap.FileHdr.magic" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.FileHdr.sigfigs">
<tt class="descname">sigfigs</tt><a class="headerlink" href="#pypacker.ppcap.FileHdr.sigfigs" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.FileHdr.snaplen">
<tt class="descname">snaplen</tt><a class="headerlink" href="#pypacker.ppcap.FileHdr.snaplen" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.FileHdr.thiszone">
<tt class="descname">thiszone</tt><a class="headerlink" href="#pypacker.ppcap.FileHdr.thiszone" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.FileHdr.v_major">
<tt class="descname">v_major</tt><a class="headerlink" href="#pypacker.ppcap.FileHdr.v_major" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.FileHdr.v_minor">
<tt class="descname">v_minor</tt><a class="headerlink" href="#pypacker.ppcap.FileHdr.v_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pypacker.ppcap.LEFileHdr">
<em class="property">class </em><tt class="descclassname">pypacker.ppcap.</tt><tt class="descname">LEFileHdr</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pypacker.ppcap.LEFileHdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypacker.pypacker.Packet" title="pypacker.pypacker.Packet"><tt class="xref py py-class docutils literal"><span class="pre">pypacker.pypacker.Packet</span></tt></a></p>
<p>pcap file header.</p>
<dl class="attribute">
<dt id="pypacker.ppcap.LEFileHdr.__hdr__">
<tt class="descname">__hdr__</tt><em class="property"> = (('magic', 'I', 2712847316), ('v_major', 'H', 2), ('v_minor', 'H', 4), ('thiszone', 'I', 0), ('sigfigs', 'I', 0), ('snaplen', 'I', 1500), ('linktype', 'I', 1))</em><a class="headerlink" href="#pypacker.ppcap.LEFileHdr.__hdr__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.LEFileHdr.linktype">
<tt class="descname">linktype</tt><a class="headerlink" href="#pypacker.ppcap.LEFileHdr.linktype" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.LEFileHdr.magic">
<tt class="descname">magic</tt><a class="headerlink" href="#pypacker.ppcap.LEFileHdr.magic" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.LEFileHdr.sigfigs">
<tt class="descname">sigfigs</tt><a class="headerlink" href="#pypacker.ppcap.LEFileHdr.sigfigs" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.LEFileHdr.snaplen">
<tt class="descname">snaplen</tt><a class="headerlink" href="#pypacker.ppcap.LEFileHdr.snaplen" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.LEFileHdr.thiszone">
<tt class="descname">thiszone</tt><a class="headerlink" href="#pypacker.ppcap.LEFileHdr.thiszone" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.LEFileHdr.v_major">
<tt class="descname">v_major</tt><a class="headerlink" href="#pypacker.ppcap.LEFileHdr.v_major" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.LEFileHdr.v_minor">
<tt class="descname">v_minor</tt><a class="headerlink" href="#pypacker.ppcap.LEFileHdr.v_minor" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pypacker.ppcap.LEPktHdr">
<em class="property">class </em><tt class="descclassname">pypacker.ppcap.</tt><tt class="descname">LEPktHdr</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pypacker.ppcap.LEPktHdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypacker.pypacker.Packet" title="pypacker.pypacker.Packet"><tt class="xref py py-class docutils literal"><span class="pre">pypacker.pypacker.Packet</span></tt></a></p>
<p>pcap packet header.</p>
<dl class="attribute">
<dt id="pypacker.ppcap.LEPktHdr.__hdr__">
<tt class="descname">__hdr__</tt><em class="property"> = (('tv_sec', 'I', 0), ('tv_usec', 'I', 0), ('caplen', 'I', 0), ('len', 'I', 0))</em><a class="headerlink" href="#pypacker.ppcap.LEPktHdr.__hdr__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.LEPktHdr.caplen">
<tt class="descname">caplen</tt><a class="headerlink" href="#pypacker.ppcap.LEPktHdr.caplen" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.LEPktHdr.len">
<tt class="descname">len</tt><a class="headerlink" href="#pypacker.ppcap.LEPktHdr.len" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.LEPktHdr.tv_sec">
<tt class="descname">tv_sec</tt><a class="headerlink" href="#pypacker.ppcap.LEPktHdr.tv_sec" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.LEPktHdr.tv_usec">
<tt class="descname">tv_usec</tt><a class="headerlink" href="#pypacker.ppcap.LEPktHdr.tv_usec" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pypacker.ppcap.PktHdr">
<em class="property">class </em><tt class="descclassname">pypacker.ppcap.</tt><tt class="descname">PktHdr</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pypacker.ppcap.PktHdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pypacker.pypacker.Packet" title="pypacker.pypacker.Packet"><tt class="xref py py-class docutils literal"><span class="pre">pypacker.pypacker.Packet</span></tt></a></p>
<p>pcap packet header.</p>
<dl class="attribute">
<dt id="pypacker.ppcap.PktHdr.__hdr__">
<tt class="descname">__hdr__</tt><em class="property"> = (('tv_sec', 'I', 0), ('tv_usec', 'I', 0), ('caplen', 'I', 0), ('len', 'I', 0))</em><a class="headerlink" href="#pypacker.ppcap.PktHdr.__hdr__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.PktHdr.caplen">
<tt class="descname">caplen</tt><a class="headerlink" href="#pypacker.ppcap.PktHdr.caplen" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.PktHdr.len">
<tt class="descname">len</tt><a class="headerlink" href="#pypacker.ppcap.PktHdr.len" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.PktHdr.tv_sec">
<tt class="descname">tv_sec</tt><a class="headerlink" href="#pypacker.ppcap.PktHdr.tv_sec" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.ppcap.PktHdr.tv_usec">
<tt class="descname">tv_usec</tt><a class="headerlink" href="#pypacker.ppcap.PktHdr.tv_usec" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpack field ondemand</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pypacker.ppcap.Reader">
<em class="property">class </em><tt class="descclassname">pypacker.ppcap.</tt><tt class="descname">Reader</tt><big>(</big><em>fileobj=None</em>, <em>filename=None</em>, <em>lowest_layer=None</em>, <em>filter=None</em>, <em>ts_conversion=True</em><big>)</big><a class="headerlink" href="#pypacker.ppcap.Reader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Simple pcap file reader supporting pcap format. Using iterators this will
return (timestamp, bytes) on standard mode and (timestamp, packet) on packet mode.
Default timestamp resolution ist nanoseconds.</p>
<dl class="method">
<dt id="pypacker.ppcap.Reader.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.ppcap.Reader.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.ppcap.Reader.get_by_indices">
<tt class="descname">get_by_indices</tt><big>(</big><em>indices</em><big>)</big><a class="headerlink" href="#pypacker.ppcap.Reader.get_by_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Return [(timestamp, [bytes|packets]), ...] for the specified indices in packet file
starting at 0 for first packet. This method won&#8217;t change the current read-pointer.</p>
<p>indices &#8211; list of indices like [0, 1, 2]. Nonexistent indices will be ignored.
return &#8211; list of (timestamp, [bytes|packets]) at positions given by indices</p>
</dd></dl>

<dl class="method">
<dt id="pypacker.ppcap.Reader.is_resolution_nano">
<tt class="descname">is_resolution_nano</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.ppcap.Reader.is_resolution_nano" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.ppcap.Reader.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.ppcap.Reader.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset file pointer to beginning</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pypacker.ppcap.Writer">
<em class="property">class </em><tt class="descclassname">pypacker.ppcap.</tt><tt class="descname">Writer</tt><big>(</big><em>fileobj=None</em>, <em>filename=None</em>, <em>snaplen=1500</em>, <em>linktype=1</em><big>)</big><a class="headerlink" href="#pypacker.ppcap.Writer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Simple pcap writer supporting pcap format.
Note: this will use nanosecond timestamp resolution.</p>
<dl class="method">
<dt id="pypacker.ppcap.Writer.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.ppcap.Writer.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.ppcap.Writer.write">
<tt class="descname">write</tt><big>(</big><em>bts</em>, <em>ts=None</em><big>)</big><a class="headerlink" href="#pypacker.ppcap.Writer.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given packet&#8217;s bytes to file.</p>
<p>bts &#8211; bytes to be written
ts &#8211; timestamp in Nanoseconds</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pypacker.ppcap._filter_dummy">
<tt class="descclassname">pypacker.ppcap.</tt><tt class="descname">_filter_dummy</tt><big>(</big><em>pkt</em><big>)</big><a class="headerlink" href="#pypacker.ppcap._filter_dummy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="producer-consumer-module">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">producer_consumer</span></tt> Module<a class="headerlink" href="#producer-consumer-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pypacker.psocket">
<span id="psocket-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">psocket</span></tt> Module<a class="headerlink" href="#module-pypacker.psocket" title="Permalink to this headline">¶</a></h2>
<p>Packet read and write routines using network sockets.</p>
<dl class="class">
<dt id="pypacker.psocket.SocketHndl">
<em class="property">class </em><tt class="descclassname">pypacker.psocket.</tt><tt class="descname">SocketHndl</tt><big>(</big><em>iface_name='lo'</em>, <em>mode=0</em>, <em>timeout=3</em><big>)</big><a class="headerlink" href="#pypacker.psocket.SocketHndl" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Simple socket handler for layer 2 and 3 reading/writing.</p>
<dl class="attribute">
<dt id="pypacker.psocket.SocketHndl.ETH_P_ALL">
<tt class="descname">ETH_P_ALL</tt><em class="property"> = 3</em><a class="headerlink" href="#pypacker.psocket.SocketHndl.ETH_P_ALL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pypacker.psocket.SocketHndl.MODE_LAYER_2">
<tt class="descname">MODE_LAYER_2</tt><em class="property"> = 0</em><a class="headerlink" href="#pypacker.psocket.SocketHndl.MODE_LAYER_2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pypacker.psocket.SocketHndl.MODE_LAYER_3">
<tt class="descname">MODE_LAYER_3</tt><em class="property"> = 1</em><a class="headerlink" href="#pypacker.psocket.SocketHndl.MODE_LAYER_3" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.psocket.SocketHndl.close">
<tt class="descname">close</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.psocket.SocketHndl.close" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.psocket.SocketHndl.recv">
<tt class="descname">recv</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.psocket.SocketHndl.recv" title="Permalink to this definition">¶</a></dt>
<dd><p>return &#8211; bytes received from network</p>
</dd></dl>

<dl class="method">
<dt id="pypacker.psocket.SocketHndl.recvp">
<tt class="descname">recvp</tt><big>(</big><em>filter_match_recv=None</em>, <em>lowest_layer=&lt;class 'pypacker.layer12.ethernet.Ethernet'&gt;</em>, <em>max_amount=1</em><big>)</big><a class="headerlink" href="#pypacker.psocket.SocketHndl.recvp" title="Permalink to this definition">¶</a></dt>
<dd><p>Receive packets from network. This does the same as calling recv() but using a receive
filter and received bytes will be converted to packets using class given by lowest_layer.
Raises socket.timeout on timeout</p>
<dl class="docutils">
<dt>filter_match_recv &#8211; filter as callback function to match packets to be retrieved.</dt>
<dd>Callback-structure: fct(packet), Return True to accept a specific packet.
Raise StopIteration to stop receiving packets, max_amount will match after all.</dd>
</dl>
<p>lowest_layer &#8211; packet class to be used to create new packets
max_amount &#8211; maximum amount of packets to be fetched
return &#8211; packets received from network as list</p>
</dd></dl>

<dl class="method">
<dt id="pypacker.psocket.SocketHndl.send">
<tt class="descname">send</tt><big>(</big><em>bts</em>, <em>dst=None</em><big>)</big><a class="headerlink" href="#pypacker.psocket.SocketHndl.send" title="Permalink to this definition">¶</a></dt>
<dd><p>Send the given bytes to network.</p>
<p>bts &#8211; the bytes to be sent
dst &#8211; destination for Layer 3 if mode is MODE_LAYER_3</p>
</dd></dl>

<dl class="method">
<dt id="pypacker.psocket.SocketHndl.sr">
<tt class="descname">sr</tt><big>(</big><em>packet_send</em>, <em>max_packets_recv=1</em>, <em>filter=None</em>, <em>lowest_layer=&lt;class 'pypacker.layer12.ethernet.Ethernet'&gt;</em><big>)</big><a class="headerlink" href="#pypacker.psocket.SocketHndl.sr" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a packet and receive answer packets. This will use information retrieved
from direction() to retrieve answer packets. Raises socket.timeout on timeout</p>
<p>packet_send &#8211; pypacker packet to be sent
max_packets_recv &#8211; max packets to be received
filter &#8211; filter as lambda function to match packets to be retrieved,</p>
<blockquote>
<div>return True to accept a specific packet</div></blockquote>
<p>lowest_layer &#8211; packet class to be used to create new packets</p>
<p>return &#8211; packets receives</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pypacker.pypacker">
<span id="pypacker-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">pypacker</span></tt> Module<a class="headerlink" href="#module-pypacker.pypacker" title="Permalink to this headline">¶</a></h2>
<p>Simple packet creation and parsing logic.</p>
<dl class="class">
<dt id="pypacker.pypacker.MetaPacket">
<em class="property">class </em><tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">MetaPacket</tt><a class="headerlink" href="#pypacker.pypacker.MetaPacket" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.type</span></tt></p>
<p>This Metaclass is a more efficient way of setting attributes than using __init__.
This is done by reading name, format and default value out of __hdr__ in every subclass.
This configuration is set one time when loading the module (not at instatiation).
Attributes can be normally accessed using &#8220;obj.field&#8221; notation.
General note: Callflaw is: __new__ (loading module) -&gt; __init__ (initiate class)</p>
<p>CAUTION:
- List et al are _SHARED_ among all instantiated classes! A copy is needed on changes to them
- New protocols: don&#8217;t use header fields having same name as methods in Packet class</p>
</dd></dl>

<dl class="class">
<dt id="pypacker.pypacker.Packet">
<em class="property">class </em><tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">Packet</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.Packet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Base packet class, with metaclass magic to generate members from self.__hdr__ field.
This class can be instatiated via:</p>
<blockquote>
<div>Packet(byte_string)
Packet(key1=val1, key2=val2, ...)</div></blockquote>
<p>Every packet got a header and a body. Body-data can be raw byte string OR a packet itself
(the body handler) which itself stores a packet etc. This continues until a packet only
contains raw bytes (highest layer). The following schema illustrates the Packet-structure:</p>
<p>[Packet:
headerfield_1
headerfield_2
...
headerfield_N
[Body -&gt; Packet:</p>
<blockquote>
<div><p>headerfield_1
...
headerfield_N
[Body: -&gt; Packet:</p>
<blockquote>
<div>headerfields
...
[Body: b&#8221;some_bytes&#8221;]</div></blockquote>
</div></blockquote>
<p>]]]</p>
<p>A header definition like __hdr__ = ((&#8220;name&#8221;, &#8220;12s&#8221;, b&#8221;defaultvalue&#8221;),) will define a header field
having the name &#8220;name&#8221;, format &#8220;12s&#8221; and default value b&#8221;defaultvalue&#8221; as bytestring. Fields will
be added in order of definition. The static variable __byte_order__ can be set to override the
default value &#8216;&gt;&#8217;. Extending classes should overwrite the &#8220;_dissect&#8221;-method in order to dissect given data.</p>
<ul class="simple">
<li>Auto-decoding of headers via given format-patterns (defined via __hdr__)</li>
<li>Auto-decoding of body-handlers (like IP -&gt; parse IP-data -&gt; add TCP-handler to IP -&gt; parse TCP-data..)</li>
<li>Access of higher layers via layer1.layer2.layerX or &#8220;layer1[layerX]&#8221; notation</li>
<li>There are three types of headers:</li>
</ul>
<ol class="arabic">
<li><dl class="first docutils">
<dt>Simple constant fields (constant format)</dt>
<dd><p class="first last">Format for __hdr__: (&#8220;name&#8221;, &#8220;format&#8221;, value)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Simple dynamic fields (byte string which changes in length)</dt>
<dd><p class="first last">Format for __hdr__: (&#8220;name&#8221;, None, b&#8221;bytestring&#8221;)
Such types MUST get initiated in _dissect() because there is no way in guessing
the correct format when unpacking values!</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>TriggerList (List containing Packets, bytes or whatever implemented)</dt>
<dd><p class="first last">Format for __hdr__: (&#8220;name&#8221;, None, TriggerList)</p>
</dd>
</dl>
</li>
</ol>
<ul>
<li><dl class="first docutils">
<dt>Convenient access for standard types (MAC, IP address) using string-representations</dt>
<dd><p class="first">This is done by appending &#8220;_s&#8221; to the attributename:
ip.src_s = &#8220;127.0.0.1&#8221;
ip_src_bytes = ip.src</p>
<p class="last">Implementation info:
Convenient access should be set via varname_s = pypacker.Packet.get_property_XXX(&#8220;varname&#8221;)
Concatination via &#8220;layer1 + layer2 + layerX&#8221;</p>
</dd>
</dl>
</li>
<li><p class="first">Header-values with length &lt; 1 Byte should be set by using properties</p>
</li>
<li><p class="first">Activate/deactivate non-TriggerList header fields by setting values (None=deactive, value=active)</p>
</li>
<li><p class="first">Checksums (static auto fields in general) are auto-recalculated when calling bin(update_auto_fields=True) (default)</p>
</li>
<li><p class="first">Ability to check direction to other Packets via &#8220;[<a href="#id1"><span class="problematic" id="id2">is_</span></a>]direction()&#8221;</p>
</li>
<li><p class="first">Access to next lower/upper layer</p>
</li>
<li><dl class="first docutils">
<dt>No correction of given raw packet-data eg checksums when creating a packet from it</dt>
<dd><p class="first last">If the packet can&#8217;t be parsed without correct data -&gt; raise exception.
The internal state will only be updated on changes to headers or data later on</p>
</dd>
</dl>
</li>
<li><p class="first">General rule: less changes to headers/body-data = more performance</p>
</li>
</ul>
<blockquote>
<div><dl class="docutils">
<dt>pypacker(bytes)</dt>
<dd><dl class="first docutils">
<dt>-&gt; _dissect(): has to be overwritten, get to know/verify the real header-structure</dt>
<dd>-&gt; (optional): call _init_handler() initiating a handler representing an upper-layer
-&gt; (optional): call _init_triggerlist(name, b&#8221;bytes&#8221;, dissect_callback) to initiate a TriggerList field</dd>
</dl>
<p class="last">-&gt; (optional) on access to simple headers: _unpack() sets all header values
-&gt; (optional) on access to TriggerList headers: lazy parsing gets triggered
-&gt; (optional) on access to body handler next upper layer gets initiated</p>
</dd>
<dt>pypacker(keyword1=value, ...)</dt>
<dd>-&gt; (optional) set headers</dd>
<dt>pypacker()</dt>
<dd>-&gt; sets standard values for simple headers</dd>
</dl>
</div></blockquote>
<dl class="attribute">
<dt id="pypacker.pypacker.Packet.DIR_REV">
<tt class="descname">DIR_REV</tt><em class="property"> = 2</em><a class="headerlink" href="#pypacker.pypacker.Packet.DIR_REV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pypacker.pypacker.Packet.DIR_SAME">
<tt class="descname">DIR_SAME</tt><em class="property"> = 1</em><a class="headerlink" href="#pypacker.pypacker.Packet.DIR_SAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pypacker.pypacker.Packet.DIR_UNKNOWN">
<tt class="descname">DIR_UNKNOWN</tt><em class="property"> = 3</em><a class="headerlink" href="#pypacker.pypacker.Packet.DIR_UNKNOWN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.pypacker.Packet.bin">
<tt class="descname">bin</tt><big>(</big><em>update_auto_fields=True</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.Packet.bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return this header and body (including all upper layers) as byte string
and reset changed-status.</p>
<p>update_auto_fields &#8211; if True auto-update fields like checksums, else leave them be</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.pypacker.Packet.body_bytes">
<tt class="descname">body_bytes</tt><a class="headerlink" href="#pypacker.pypacker.Packet.body_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return raw data bytes or handler bytes (including all upper layers) if present.
This is the same as calling bin() but excluding this header and without resetting changed-status.</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.pypacker.Packet.body_handler">
<tt class="descname">body_handler</tt><a class="headerlink" href="#pypacker.pypacker.Packet.body_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>return &#8211; handler object or None if not present.</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.pypacker.Packet.data">
<tt class="descname">data</tt><a class="headerlink" href="#pypacker.pypacker.Packet.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return raw data bytes or handler bytes (including all upper layers) if present.
This is the same as calling bin() but excluding this header and without resetting changed-status.</p>
</dd></dl>

<dl class="method">
<dt id="pypacker.pypacker.Packet.direction">
<tt class="descname">direction</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.Packet.direction" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.pypacker.Packet.direction_all">
<tt class="descname">direction_all</tt><big>(</big><em>other_packet</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.Packet.direction_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for direction on ALL layers from this one upwards.
This continues upwards until no body handler can be found anymore.
The extending class can overwrite direction() to implement an individual check,
signature: direction(self, other_packet) return [same as direction_all]</p>
<p>other_packet &#8211; Packet to be compared with this Packet
return &#8211; Bitwise OR-concatination of all directions of ALL layers starting from</p>
<blockquote>
<div>this one upwards. Directions are: [DIR_SAME | DIR_REV | DIR_UNKNOWN].
This can be checked via eg &#8220;direction_found &amp; DIR_SAME&#8221;</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="pypacker.pypacker.Packet.dissect_full">
<tt class="descname">dissect_full</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.pypacker.Packet.dissect_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursive unpack ALL data inlcuding lazy header etc up to highest layer inlcuding danymic fields.</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.pypacker.Packet.header_bytes">
<tt class="descname">header_bytes</tt><a class="headerlink" href="#pypacker.pypacker.Packet.header_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return header as byte string.</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.pypacker.Packet.header_len">
<tt class="descname">header_len</tt><a class="headerlink" href="#pypacker.pypacker.Packet.header_len" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.pypacker.Packet.hexdump">
<tt class="descname">hexdump</tt><big>(</big><em>length=16</em>, <em>only_header=False</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.Packet.hexdump" title="Permalink to this definition">¶</a></dt>
<dd><p>length &#8211; amount of bytes per line
only_header &#8211; if True: just dump header, else header + body (default)</p>
<p>return &#8211; hexdump output string for this packet (header or header + body).</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.pypacker.Packet.highest_layer">
<tt class="descname">highest_layer</tt><a class="headerlink" href="#pypacker.pypacker.Packet.highest_layer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.pypacker.Packet.is_direction">
<tt class="descname">is_direction</tt><big>(</big><em>packet2</em>, <em>direction</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.Packet.is_direction" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as &#8220;direction_all()&#8221; but using explicit direction to be checked.
As direction_all can be DIR_SAME and DIR_REV at the same time, this call
is more clearly.</p>
<p>packet2 &#8211; packet to be compared to this packet
direction &#8211; check for this direction (<a href="#id3"><span class="problematic" id="id4">DIR_</span></a>...)
return &#8211; True if direction is found in this packet, False otherwise.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pypacker.pypacker.Packet.load_handler">
<em class="property">classmethod </em><tt class="descname">load_handler</tt><big>(</big><em>clz</em>, <em>clz_add</em>, <em>handler</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.Packet.load_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Load Packet handler using a shared dictionary.</p>
<p>clz_add &#8211; class for which handler has to be added
handler &#8211; dict of handlers to be set like { id : class }, id can be a tuple of values</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.pypacker.Packet.lower_layer">
<tt class="descname">lower_layer</tt><a class="headerlink" href="#pypacker.pypacker.Packet.lower_layer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pypacker.pypacker.Packet.lowest_layer">
<tt class="descname">lowest_layer</tt><a class="headerlink" href="#pypacker.pypacker.Packet.lowest_layer" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.pypacker.Packet.reverse_address">
<tt class="descname">reverse_address</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.pypacker.Packet.reverse_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse source &lt;-&gt; destination address of THIS packet. This is at minimum defined for: Ethernet, IP, TCP, UDP</p>
</dd></dl>

<dl class="method">
<dt id="pypacker.pypacker.Packet.reverse_all_address">
<tt class="descname">reverse_all_address</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.pypacker.Packet.reverse_all_address" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse source &lt;-&gt; destination address of EVERY packet upwards including this one (reverse_address has to be implemented).</p>
</dd></dl>

<dl class="attribute">
<dt id="pypacker.pypacker.Packet.upper_layer">
<tt class="descname">upper_layer</tt><a class="headerlink" href="#pypacker.pypacker.Packet.upper_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>return &#8211; handler object or None if not present.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pypacker.pypacker.UnpackError">
<em class="property">exception </em><tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">UnpackError</tt><a class="headerlink" href="#pypacker.pypacker.UnpackError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.Exception</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.byte2hex">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">byte2hex</tt><big>(</big><em>buf</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.byte2hex" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a bytestring to a hex-represenation:
b&#8216;1234&#8217; -&gt; &#8216;1234&#8217;</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.dns_name_decode">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">dns_name_decode</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.dns_name_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>DNS domain name decoder (bytes to string)</p>
<p>name &#8211; example: b&#8221;wwwexamplecom&#8221;
return &#8211; example: &#8220;www.example.com.&#8221;</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.dns_name_encode">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">dns_name_encode</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.dns_name_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>DNS domain name encoder (string to bytes)</p>
<p>name &#8211; example: &#8220;www.example.com&#8221;
return &#8211; example: b&#8217;wwwexamplecom&#8217;</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.get_property_dnsname">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">get_property_dnsname</tt><big>(</big><em>var</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.get_property_dnsname" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a get/set-property for a DNS name.</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.get_property_ip4">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">get_property_ip4</tt><big>(</big><em>var</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.get_property_ip4" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a get/set-property for an IP4 address as string-representation.</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.get_property_mac">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">get_property_mac</tt><big>(</big><em>varname</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.get_property_mac" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a get/set-property for a MAC address as string-representation.</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.get_rnd_ipv4">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">get_rnd_ipv4</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.pypacker.get_rnd_ipv4" title="Permalink to this definition">¶</a></dt>
<dd><p>Create random ipv4 adress as bytestring</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.get_rnd_mac">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">get_rnd_mac</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.pypacker.get_rnd_mac" title="Permalink to this definition">¶</a></dt>
<dd><p>Create random mac address as bytestring</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.ip4_bytes_to_str">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">ip4_bytes_to_str</tt><big>(</big><em>ip_bytes</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.ip4_bytes_to_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert ip address from byte representation to 127.0.0.1.</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.ip4_str_to_bytes">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">ip4_str_to_bytes</tt><big>(</big><em>ip_str</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.ip4_str_to_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert ip address 127.0.0.1 to byte representation.</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.mac_bytes_to_str">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">mac_bytes_to_str</tt><big>(</big><em>mac_bytes</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.mac_bytes_to_str" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert mac address from byte representation to AA:BB:CC:DD:EE:FF.</p>
</dd></dl>

<dl class="function">
<dt id="pypacker.pypacker.mac_str_to_bytes">
<tt class="descclassname">pypacker.pypacker.</tt><tt class="descname">mac_str_to_bytes</tt><big>(</big><em>mac_str</em><big>)</big><a class="headerlink" href="#pypacker.pypacker.mac_str_to_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert mac address AA:BB:CC:DD:EE:FF to byte representation.</p>
</dd></dl>

</div>
<div class="section" id="module-pypacker.triggerlist">
<span id="triggerlist-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">triggerlist</span></tt> Module<a class="headerlink" href="#module-pypacker.triggerlist" title="Permalink to this headline">¶</a></h2>
<p>TriggerList for handling dynamic headers.</p>
<dl class="class">
<dt id="pypacker.triggerlist.TriggerList">
<em class="property">class </em><tt class="descclassname">pypacker.triggerlist.</tt><tt class="descname">TriggerList</tt><big>(</big><em>packet</em>, <em>dissect_callback=None</em>, <em>buffer=b''</em><big>)</big><a class="headerlink" href="#pypacker.triggerlist.TriggerList" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.list</span></tt></p>
<p>List with trigger-capabilities representing a Packet header.
This list can contain one type of raw bytes, tuples or packets representing an individual
header field. Using bytes or tuples &#8220;_pack()&#8221; can be overwritten to reassemble bytes.</p>
<dl class="method">
<dt id="pypacker.triggerlist.TriggerList.append">
<tt class="descname">append</tt><big>(</big><em>v</em><big>)</big><a class="headerlink" href="#pypacker.triggerlist.TriggerList.append" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.triggerlist.TriggerList.bin">
<tt class="descname">bin</tt><big>(</big><big>)</big><a class="headerlink" href="#pypacker.triggerlist.TriggerList.bin" title="Permalink to this definition">¶</a></dt>
<dd><p>Output the TriggerLists elements as concatenated bytestring.
Custom implementations can be set by overwriting _pack().</p>
</dd></dl>

<dl class="method">
<dt id="pypacker.triggerlist.TriggerList.extend">
<tt class="descname">extend</tt><big>(</big><em>v</em><big>)</big><a class="headerlink" href="#pypacker.triggerlist.TriggerList.extend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pypacker.triggerlist.TriggerList.find_pos">
<tt class="descname">find_pos</tt><big>(</big><em>search_cb</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#pypacker.triggerlist.TriggerList.find_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Find an item-position giving search callback as search criteria.</p>
<dl class="docutils">
<dt>search_cb &#8211; callback to compare values, signature: callback(value) [True|False]</dt>
<dd>Return True to return value found.</dd>
</dl>
<p>offset &#8211; start at index &#8220;offset&#8221; to search
return &#8211; index of first element found or None</p>
</dd></dl>

<dl class="method">
<dt id="pypacker.triggerlist.TriggerList.find_value">
<tt class="descname">find_value</tt><big>(</big><em>search_cb</em>, <em>offset=0</em><big>)</big><a class="headerlink" href="#pypacker.triggerlist.TriggerList.find_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as find_pos() but directly returning found value or None.</p>
</dd></dl>

<dl class="method">
<dt id="pypacker.triggerlist.TriggerList.insert">
<tt class="descname">insert</tt><big>(</big><em>pos</em>, <em>v</em><big>)</big><a class="headerlink" href="#pypacker.triggerlist.TriggerList.insert" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pypacker.layer12.html">layer12 Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#module-pypacker.layer12.arp"><tt class="docutils literal"><span class="pre">arp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#cdp-module"><tt class="docutils literal"><span class="pre">cdp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#module-pypacker.layer12.dtp"><tt class="docutils literal"><span class="pre">dtp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#module-pypacker.layer12.ethernet"><tt class="docutils literal"><span class="pre">ethernet</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#module-pypacker.layer12.ieee80211"><tt class="docutils literal"><span class="pre">ieee80211</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#ieee80211-bak-module"><tt class="docutils literal"><span class="pre">ieee80211_bak</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#module-pypacker.layer12.llc"><tt class="docutils literal"><span class="pre">llc</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#module-pypacker.layer12.ppp"><tt class="docutils literal"><span class="pre">ppp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#module-pypacker.layer12.pppoe"><tt class="docutils literal"><span class="pre">pppoe</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#module-pypacker.layer12.prism"><tt class="docutils literal"><span class="pre">prism</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#module-pypacker.layer12.radiotap"><tt class="docutils literal"><span class="pre">radiotap</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#module-pypacker.layer12.stp"><tt class="docutils literal"><span class="pre">stp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer12.html#module-pypacker.layer12.vrrp"><tt class="docutils literal"><span class="pre">vrrp</span></tt> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pypacker.layer3.html">layer3 Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer3.html#module-pypacker.layer3.esp"><tt class="docutils literal"><span class="pre">esp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer3.html#module-pypacker.layer3.icmp"><tt class="docutils literal"><span class="pre">icmp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer3.html#module-pypacker.layer3.icmp6"><tt class="docutils literal"><span class="pre">icmp6</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer3.html#module-pypacker.layer3.igmp"><tt class="docutils literal"><span class="pre">igmp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer3.html#module-pypacker.layer3.ip"><tt class="docutils literal"><span class="pre">ip</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer3.html#module-pypacker.layer3.ip6"><tt class="docutils literal"><span class="pre">ip6</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer3.html#module-pypacker.layer3.ip_shared"><tt class="docutils literal"><span class="pre">ip_shared</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer3.html#module-pypacker.layer3.ipx"><tt class="docutils literal"><span class="pre">ipx</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer3.html#module-pypacker.layer3.ospf"><tt class="docutils literal"><span class="pre">ospf</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer3.html#module-pypacker.layer3.pim"><tt class="docutils literal"><span class="pre">pim</span></tt> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pypacker.layer4.html">layer4 Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer4.html#sccp-module"><tt class="docutils literal"><span class="pre">sccp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer4.html#module-pypacker.layer4.sctp"><tt class="docutils literal"><span class="pre">sctp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer4.html#module-pypacker.layer4.ssl"><tt class="docutils literal"><span class="pre">ssl</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer4.html#module-pypacker.layer4.tcp"><tt class="docutils literal"><span class="pre">tcp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer4.html#module-pypacker.layer4.udp"><tt class="docutils literal"><span class="pre">udp</span></tt> Module</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pypacker.layer567.html">layer567 Package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.bgp"><tt class="docutils literal"><span class="pre">bgp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.dhcp"><tt class="docutils literal"><span class="pre">dhcp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.diameter"><tt class="docutils literal"><span class="pre">diameter</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.dns"><tt class="docutils literal"><span class="pre">dns</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.hsrp"><tt class="docutils literal"><span class="pre">hsrp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.http"><tt class="docutils literal"><span class="pre">http</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#netflow-module"><tt class="docutils literal"><span class="pre">netflow</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.ntp"><tt class="docutils literal"><span class="pre">ntp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.pmap"><tt class="docutils literal"><span class="pre">pmap</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.radius"><tt class="docutils literal"><span class="pre">radius</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#rfb-module"><tt class="docutils literal"><span class="pre">rfb</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.rip"><tt class="docutils literal"><span class="pre">rip</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#rpc-module"><tt class="docutils literal"><span class="pre">rpc</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.rtp"><tt class="docutils literal"><span class="pre">rtp</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.sip"><tt class="docutils literal"><span class="pre">sip</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#smb-module"><tt class="docutils literal"><span class="pre">smb</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#ssl-ciphersuites-module"><tt class="docutils literal"><span class="pre">ssl_ciphersuites</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.telnet"><tt class="docutils literal"><span class="pre">telnet</span></tt> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pypacker.layer567.html#module-pypacker.layer567.tpkt"><tt class="docutils literal"><span class="pre">tpkt</span></tt> Module</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pypacker Package</a><ul>
<li><a class="reference internal" href="#module-pypacker.checksum"><tt class="docutils literal"><span class="pre">checksum</span></tt> Module</a></li>
<li><a class="reference internal" href="#gzip-module"><tt class="docutils literal"><span class="pre">gzip</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pypacker.ppcap"><tt class="docutils literal"><span class="pre">ppcap</span></tt> Module</a></li>
<li><a class="reference internal" href="#producer-consumer-module"><tt class="docutils literal"><span class="pre">producer_consumer</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pypacker.psocket"><tt class="docutils literal"><span class="pre">psocket</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pypacker.pypacker"><tt class="docutils literal"><span class="pre">pypacker</span></tt> Module</a></li>
<li><a class="reference internal" href="#module-pypacker.triggerlist"><tt class="docutils literal"><span class="pre">triggerlist</span></tt> Module</a></li>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/pypacker.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">Pypacker 3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Michael Stahn.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>