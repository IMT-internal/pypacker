# $Id: http.py 80 2011-01-06 16:50:42Z jon.oberheide $

"""Hypertext Transfer Protocol.
In contrast to the low-layer protocols HTTP-headers are stored via a dict
like {headername : value} in "headers" inclusive reqest/response line.
This will be the exact same header but without ": ".
"""

import pypacker as pypacker
import re

class HTTP(pypacker.Packet):
	__hdr__ = (("h", "1s", "")
		)

	"""Hypertext Transfer Protocol headers + body."""
	__req_methods = (
		'GET', 'PUT', 'ICY',
		'COPY', 'HEAD', 'LOCK', 'MOVE', 'POLL', 'POST',
		'BCOPY', 'BMOVE', 'MKCOL', 'TRACE', 'LABEL', 'MERGE',
		'DELETE', 'SEARCH', 'UNLOCK', 'REPORT', 'UPDATE', 'NOTIFY',
		'BDELETE', 'CONNECT', 'OPTIONS', 'CHECKIN',
		'PROPFIND', 'CHECKOUT', 'CCM_POST',
		'SUBSCRIBE', 'PROPPATCH', 'BPROPFIND',
		'BPROPPATCH', 'UNCHECKOUT', 'MKACTIVITY',
		'MKWORKSPACE', 'UNSUBSCRIBE', 'RPC_CONNECT',
		'VERSION-CONTROL',
		'BASELINE-CONTROL'
		)

	def __setattr__(self, k, v):
		if k is "h":
			raise Error("can't set header directly, please use headers-dict")
		pypacker.Packet.__setattr__(self, k, v)

	def unpack(self, buf):
		#f = io.StringIO(buf)
		header, body = re.split(b"\r\n\r\n", buf, 2)
		header += "\r\n"
		# parse headers
		# requestline: [method] [uri] [version] -> GET / HTTP/1.1
		# responseline: [version] [status] [reason] -> HTTP/1.1 200 OK
		req_resp, headers_parsed = parse_headers(header)
		self.headers = TriggerDict(headers_parsed)
		self.headers[b"startline"] = req_resp
		self.headers.callback = self.__update_header_callback
		# parse body
		#self.body = parse_body(f, self.headers)
		pypacker.packet.unpack(buf)

	def __update_header_callback(self):
		logger.debug("dict callback called")
		# dicts should be sorted uniquely, reassemble like given, skip "startline"
		keys = self.header.keys()
		headerlines = [ b"%s: %s" % (k, self.header[k]) for k in keys[:-1] ]
		header_new = self.header["startline"] + b"\r\n" + b"\r\n".join(headerlines) + b"\r\n\r\n")
		object.__setattr__("h", header_new)
		self._set_headerformat("h", "%ss" % len(header_new))


def parse_headers(header):
	"""Return the request/responseline and dict of HTTP headers parsed from a byte-array."""
	lines = re.split(b"\r\n", header)
	req_resp = lines[0]
	del lines[0]

	header_key_value = {}

	for line in lines:
		key, val = lines.split(b": ", lines, 2)
		header_key_value[ key ] = val

	return req_resp, header_key_value

def parse_body(buf, headers):
	"""Return HTTP body parsed from a file object, given HTTP header dict."""
	headers_lower = [ k.lower() for k in headers.keys()]
	if "transfer-encoding" in headers_lower:
		# search for value of "transfer-encoding", no easy way beacuse possible upper/lowercase mix
		transfer_val = [ v.lower().strip() for k,v in headers if k.lower() is "transfer-encoding" ]

	if transfer_val is "chunked":
		logger.debug("got chunked encoding")
		f = io.StringIO(buf)
		l = []
		found_end = False
		while 1:
			try:
				sz = f.readline().split(None, 1)[0]
			except IndexError:
				raise pypacker.UnpackError('missing chunk size')
			n = int(sz, 16)
			if n == 0:
				found_end = True
			buf = f.read(n)
			if f.readline().strip():
				break
			if n and len(buf) == n:
				l.append(buf)
			else:
				break
		if not found_end:
			raise pypacker.NeedData('premature end of chunked body')
		body = ''.join(l)
	else:
		body = buf
	return body

