import unittest
import sys
# pypacker-specific imports
import pypacker
from pypacker import Packet
import ppcap as ppcap
#from ppcap import Reader
#from pypacker.pcap import FileHdr, LEFileHdr
from layer12.arp import ARP
from layer12.ethernet import Ethernet
from layer12.ospf import OSPF
from layer12.ppp import PPP
from layer12.stp import STP
from layer12.vrrp import VRRP
from layer3.ah import AH
from layer3.ip import IP
from layer3.ipx import IPX
from layer3.icmp import ICMP
from layer3.igmp import IGMP
from layer3.pim import PIM
from layer4.tcp import TCP
from layer4.tcp import TCP_OPT_WSCALE, TCP_OPT_TIMESTAMP
from layer4.udp import UDP
import layer4.sctp as sctp
from layer4.sctp import SCTP, DATA
from layer567.dhcp import DHCP, DHCP_OPT_TCPTTL
from layer567.http import HTTP, HTTPTriggerList
from layer567.ntp import NTP
from layer567 import ntp
from layer567.rip import RIP
from layer567.rtp import RTP
from layer567.tftp import TFTP
#from pypacker.asn1 import decode
#from pypacker.pypacker import UnpackError
#from pypacker import bgp
#from pypacker.bgp import BGP
#from pypacker.diameter import Diameter
#from pypacker import ethernet
#from pypacker import h225
#from pypacker.h225 import H225
#from pypacker.http import Request, Response
#from pypacker import ieee80211
#from pypacker.ieee80211 import IEEE80211
#from pypacker.dns import DNS, pack_name
#from pypacker.ip6 import IP6, IP6AHHeader, IP6HopOptsHeader, IP6FragmentHeader, IP6OptsHeader, IP6DstOptsHeader
#from pypacker.radiotap import Radiotap
#from pypacker.netflow import Netflow1
#from pypacker.llc import LLC
#from pypacker import telnet
#from pypacker.telnet import strip_options
import time

# Things to test on every protocol:
# - raw byte parsing
# - header changes
# - direction of packages
# - checksums
# - dynamic/optional headers
# General testcases:
# - Concatination via "+" (+parsing)
# - type finding via packet[type]
#
# Successfully tested:
# - Ethernet
# - ARP
# - STP
# - PPP
# - PPPoE
# - OSPF
# - STP
# - VRRP
#
# - IP
# - ICMP
# - PIM
# - AH
# - ESP
# - IGMP
# - IPX
#
# - TCP
# - UDP
# - SCTP
#
# - HTTP
# - NTP
# - RTP
# - DHCP
# - RIP
# - SIP
# - TFTP
# - AIM
# 
# TBD:
# - CDP
# - DTP
# - LLC
# - Radiotap
# - Snoop
# - GRE
# - ICMP6
# - IP6
# - NetBios
# - SCCP
# - BGP
# - Diameter
# - DNS <
# - HSRP
# - Netflow
# - PMAP
# - Radius
# - RFB
# - RPC
# - RX
# - SMB
# - SSL <
# - STUN
# - Telnet
# - TNS
# - TPKT
# - Yahoo

# some predefined layers
# 
# dst="52:54:00:12:35:02" src="08:00:27:a9:93:9e" type="0x08x00", type=2048
BYTES_ETH	= b"\x52\x54\x00\x12\x35\x02\x08\x00\x27\xa9\x93\x9e\x08\x00"
# src="10.0.2.15", dst="10.32.194.141", type=6 (TCP)
BYTES_IP	= b"\x45\x00\x00\xff\xc5\x78\x40\x00\x40\x06\x9c\x81\x0a\x00\x02\x0f\x0a\x20\xc2\x8d"
# sport=6667, dport=55211, win=46
BYTES_TCP	= b"\x1a\x0b\x00\x50\xb9\xb7\x74\xa9\xbc\x5b\x83\xa9\x80\x10\x00\x2e\xc0\x09\x00\x00\x01\x01\x08\x0a\x28\x2b\x0f\x9e\x05\x77\x1b\xe3"
# sport=38259, dport=53
BYTES_UDP	= b"\x95\x73\x00\x35\x00\x23\x81\x49"
BYTES_HTTP	= b"GET / HTTP/1.1\r\nHeader1: value1\r\nHeader2: value2\r\n\r\nThis is the body content\r\n"
BYTES_ETH_IP_TCP_HTTP = BYTES_ETH + BYTES_IP + BYTES_TCP + BYTES_HTTP
#
## DHCP
# options=7: 53, 50, 57, 60, 12, 55, 255
BYTES_DHCP_REQ = b"\x01\x01\x06\x00\xf7\x24\x21\x68\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x12\x23\x03\x57\x25\x7c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x63\x82\x53\x63\x35\x01\x03\x32\x04\xc0\xa8\xb2\x15\x39\x02\x05\xdc\x3c\x31\x64\x68\x63\x70\x63\x64\x2d\x35\x2e\x36\x2e\x34\x3a\x4c\x69\x6e\x75\x78\x2d\x33\x2e\x35\x2e\x37\x2d\x67\x65\x6e\x74\x6f\x6f\x3a\x69\x36\x38\x36\x3a\x47\x65\x6e\x75\x69\x6e\x65\x49\x6e\x74\x65\x6c\x0c\x06\x6c\x6f\x72\x69\x6f\x74\x37\x0f\x01\x79\x21\x03\x06\x0c\x0f\x1a\x1c\x2a\x33\x36\x3a\x3b\x77\xff"
# options=12: 53, 54, 51, 58, 59, 1, 3, 6, 15, 28, 42, 255
BYTES_DHCP_RESP = b"\x02\x01\x06\x00\xf7\x24\x21\x68\x00\x00\x00\x00\x00\x00\x00\x00\xc0\xa8\xb2\x15\xc0\xa8\xb2\x01\x00\x00\x00\x00\x12\x23\x03\x57\x25\x7c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x63\x82\x53\x63\x35\x01\x05\x36\x04\xc0\xa8\xb2\x01\x33\x04\x00\x0d\x2f\x00\x3a\x04\x00\x06\x97\x80\x3b\x04\x00\x0b\x89\x20\x01\x04\xff\xff\xff\x00\x03\x04\xc0\xa8\xb2\x01\x06\x04\xc0\xa8\xb2\x01\x0f\x09\x66\x72\x69\x74\x7a\x2e\x62\x6f\x78\x1c\x04\xc0\xa8\xb2\xff\x2a\x04\xc0\xa8\xb2\x01\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
BYTES_UDP_DHCPREQ = b"\x00\x44\x00\x43" + BYTES_UDP[4:] + BYTES_DHCP_REQ
BYTES_UDP_DHCPRESP = b"\x00\x43\x00\x44" + BYTES_UDP[4:] + BYTES_DHCP_RESP
## ICMP
# type=8, checksum=0xEC66, id=2481
BYTES_ETH_IP_ICMPREQ	= b"\x52\x54\x00\x12\x35\x02\x08\x00\x27\xa9\x93\x9e\x08\x00\x45\x00\x00\x54\x00\x00\x40\x00\x40\x01\x54\xc1\x0a\x00\x02\x0f\xad\xc2\x2c\x17\x08\x00\xec" +\
			  b"\x66\x09\xb1\x00\x01\xd0\xd5\x18\x51\x28\xbd\x05\x00\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f" +\
			  b"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37"
## DNS
# questions=1, flags=standard query, 1 query: Name=www.exploit-de.com
BYTES_DNS_REQ = b"\xb3\xe8\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x03\x77\x77\x77\x0a\x65\x78\x70\x6c\x6f\x69\x74\x2d\x64\x62\x03\x63\x6f\x6d\x00\x00\x01\x00\x01"
# questions=1, flags=standard query response, refused, 1 query: Name=www.exploit-de.com
BYTES_DNS_RESP = b"\xb3\xe8\x81\x85\x00\x01\x00\x00\x00\x00\x00\x00\x03\x77\x77\x77\x0a\x65\x78\x70\x6c\x6f\x69\x74\x2d\x64\x62\x03\x63\x6f\x6d\x00\x00\x01\x00\x01"
BYTES_ETH_IP_UDP_DNSREQ = BYTES_ETH + BYTES_IP[:9] + b"\x17" + BYTES_IP[10:] + BYTES_UDP + BYTES_DNS_REQ
BYTES_ETH_IP_UDP_DNSRESP = BYTES_ETH + BYTES_IP[:9] + b"\x17" + BYTES_IP[10:] + BYTES_UDP + BYTES_DNS_RESP
## NTP, port=123 (0x7B)
BYTES_NTP = BYTES_UDP[:3] + b"\x7B" + BYTES_UDP[4:] + b"\x24\x02\x04\xef\x00\x00\x00\x84\x00\x00\x33\x27\xc1\x02\x04\x02\xc8\x90\xec\x11\x22\xae\x07\xe5\xc8\x90\xf9\xd9\xc0\x7e\x8c\xcd\xc8\x90\xf9\xd9\xda\xc5\xb0\x78\xc8\x90\xf9\xd9\xda\xc6\x8a\x93"
## RIP
BYTES_RIP = b"\x02\x02\x00\x00\x00\x02\x00\x00\x01\x02\x03\x00\xff\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x02\x00\x00\xc0\xa8\x01\x08\xff\xff\xff\xfc\x00\x00\x00\x00\x00\x00\x00\x01"
## SCTP
BYTES_SCTP = b"\x80\x44\x00\x50\x00\x00\x00\x00\x30\xba\xef\x54\x01\x00\x00\x3c\x3b\xb9\x9c\x46\x00\x01\xa0\x00\x00\x0a\xff\xff\x2b\x2d\x7e\xb2\x00\x05\x00\x08\x9b\xe6\x18\x9b\x00\x05\x00\x08\x9b\xe6\x18\x9c\x00\x0c\x00\x06\x00\x05\x00\x00\x80\x00\x00\x04\xc0\x00\x00\x04\xc0\x06\x00\x08\x00\x00\x00\x00"


class CreateTestCase(unittest.TestCase):
	def test_create_eth(self):
		print(">>>>>>>>> CREATE TEST <<<<<<<<<")
		eth = Ethernet()
		#print(str(eth))
		self.failUnless(eth.bin() == b"\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x08\x00")
		eth = Ethernet(dst=b"\x00\x01\x02\x03\x04\x05", src=b"\x06\x07\x08\x09\x0A\x0B", type=2048)
		print(str(eth))
		print(eth.bin())
		self.failUnless(eth.bin() == b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x08\x00")
		
class EthTestCase(unittest.TestCase):
	def test_eth(self):
		print(">>>>>>>>> ETHERNET <<<<<<<<<")
		# Ethernet without body
		s = b"\x52\x54\x00\x12\x35\x02\x08\x00\x27\xa9\x93\x9e\x08\x00"
		eth1 = Ethernet(s)
		# parsing
		self.failUnless(eth1.bin() == s)
		self.failUnless(eth1.dst_s == "52:54:00:12:35:02")
		self.failUnless(eth1.src_s == "08:00:27:a9:93:9e")
		# header field update
		mac1 = "aa:bb:cc:dd:ee:00"
		mac2 = "aa:bb:cc:dd:ee:01"
		eth1.dst_s = mac2
		eth1.src_s = mac1
		self.failUnless(eth1.dst_s == mac2)
		self.failUnless(eth1.src_s == mac1)
		# TODO: removed option "fieldvalue = None"
		#oldlen = len(eth1)
		#eth1.dst = None
		#self.failUnless(eth1.dst == None)
		# removed 6-byte ethernet address
		#self.failUnless(oldlen == len(eth1) + 6)
		# Ethernet + IP
		s= b"\x52\x54\x00\x12\x35\x02\x08\x00\x27\xa9\x93\x9e\x08\x00\x45\x00\x00\x37\xc5\x78\x40\x00\x40\x11\x9c\x81\x0a\x00\x02\x0f\x0a\x20\xc2\x8d"
		eth2 = Ethernet(s)
		# parsing
		self.failUnless(eth2.bin() == s)
		self.failUnless(type(eth2.ip).__name__ == "IP")
		print("Ethernet with IP: %s -> %s" % (eth2.ip.src, eth2.ip.dst))
		# reconstruate macs
		eth1.src = b"\x52\x54\x00\x12\x35\x02"
		eth1.dst = b"\x08\x00\x27\xa9\x93\x9e"
		# direction
		print("direction of eth: %d" % eth1.direction(eth1))
		self.failUnless(eth1.direction(eth1) == Packet.DIR_SAME)
		
class IPTestCase(unittest.TestCase):
	def test_IP(self):
		print(">>>>>>>>> IP <<<<<<<<<")
		# IP without body
		s1 = b"\x45\x00\x00\x37\xc5\x78\x40\x00\x40\x11\x9c\x81\x0a\x00\x02\x0f\x0a\x20\xc2\x8d"
		ip1 = IP(s1)
		# parsing
		self.failUnless(ip1.bin() == s1)
		self.failUnless(ip1.src_s == "10.0.2.15")
		self.failUnless(ip1.dst_s == "10.32.194.141")
		print("src: %s" % ip1.src_s)			
		# header field udpate
		src = "1.2.3.4"
		dst = "4.3.2.1"
		print(ip1)
		ip1.src_s = src
		ip1.dst_s = dst
		self.failUnless(ip1.src_s == src)
		self.failUnless(ip1.dst_s == dst)		
		# TODO: removed option "fieldvalue = None"
		#oldlen = len(ip1)
		#ip1.src = None
		#self.failUnless(ip1.src == None)
		## removed 4-byte IP address
		#self.failUnless(oldlen == len(ip1) + 4)
		# IP + UDP (0x11 = 17)
		s = b"\x45\x00\x00\x37\x19\x6c\x40\x00\x40\x11\x9c\x3b\xe2\x00\x02\x0f\x0a\x20\xc2\x8d\x87\x8c\x00\x35\x00\x23\xd8\xf0"
		ip2 = IP(s)
		# parsing
		self.failUnless(ip2.bin() == s)
		self.failUnless(type(ip2.udp).__name__ == "UDP")
		print("IP with UDP: %s -> %s" % (ip2.udp.sport, ip2.udp.dport))
		# reconstruate macs
		ip1.src = b"\x0a\x00\x02\x0f"
		ip1.dst = b"\x0a\x20\xc2\x8d"
		# direction
		self.failUnless(ip1.direction(ip1) == Packet.DIR_SAME)
		# IP (checksum: 0x3be2 = 15330)
		s = b"\x45\x00\x00\x37\x19\x6c\x40\x00\x40\x11\x3b\xe2\xc0\xa8\xb2\x15\xc0\xa8\xb2\x01"
		# checksum
		print(">>> checksum")
		ip3 = IP(s)
		print("IP sum 1: %s" % ip3.sum)
		self.failUnless(ip3.sum == 15330)
		ip3.p = 17
		ip3.src = b"\xc0\xa8\xb2\x15"
		ip3.dst = b"\xc0\xa8\xb2\x01"
		print("IP sum 2: %s" % ip3.sum)
		self.failUnless(ip3.sum == 15330)
		ip3.p = 6
		print("IP sum 3: %s" % ip3.sum)
		self.failUnless(ip3.sum == 15341)
		# IP + options
		s4 = s1 + b"\x03\02\x00\x07" + b"\x09\01\x07" + b"\x01"
		s4 = b"\x47" + s4[1:]	# IP header length = 7*4
		ip4 = IP(s4)
		self.failUnless(ip4.bin() == s4)
		del ip4.opts[2]
		self.failUnless(len(ip4.opts) == 2)
		self.failUnless(ip4.opts[0].type == 3)
		self.failUnless(ip4.opts[0].len == 2)
		self.failUnless(ip4.opts[0].data == b"\x00\x07")


class TCPTestCase(unittest.TestCase):
	def test_TCP(self):
		print(">>>>>>>>> TCP <<<<<<<<<")
		# TCP without body
		s = b"\x1a\x0b\xd7\xab\xb9\xb7\x74\xa9\xbc\x5b\x83\xa9\x80\x10\x00\x2e\xc0\x09\x00\x00\x01\x01\x08\x0a\x28\x2b\x0f\x9e\x05\x77\x1b\xe3"
		tcp1 = TCP(s)
		# parsing
		self.failUnless(tcp1.bin() == s)
		self.failUnless(tcp1.sport == 6667)
		self.failUnless(tcp1.dport == 55211)
		# header field udpate
		sport = 124
		dport = 322
		tcp1.sport = sport
		tcp1.dport = dport
		self.failUnless(tcp1.sport == sport)
		self.failUnless(tcp1.dport == dport)
		# TODO: removed option "fieldvalue = None"
		#oldlen = len(tcp1)
		#tcp1.sport = None
		#self.failUnless(tcp1.sport == None)
		## removed 4-byte IP address
		#self.failUnless(oldlen == len(tcp1) + 2)
		# TCP without body
		#s = b"\x1a\x0b\xd7\xab\xb9\xb7\x74\xa9\xbc\x5b\x83\xa9\x80\x10\x00\x2e\xc0\x09\x00\x00\x01\x01\x08\x0a\x28\x2b\x0f\x9e\x05\x77\x1b\xe3"
		tcp2 = TCP(s)
		# reconstruate ports
		tcp1.sport = 6667
		tcp1.dport = 55211
		print("dir: %d" % tcp1.direction(tcp2))
		self.failUnless(tcp1.direction(tcp2) == Packet.DIR_SAME)
		# checksum (no IP-layer means no checksum change)
		tcp1.win = 1234
		self.failUnless(tcp1.sum == 49161)	# 0xc009
		# Ether + IP + TCP
		s = b"\x24\x77\x03\x53\x25\x7c\x24\x65\x11\x85\xe9\xac\x08\x00\x45\x00\x00\x34\x88\x92\x40\x00\x35\x06\xbf\xec\x82\x85\x08\x02\xc0\xa8\xb2\x15\x1a\x0b\xd7\xab\xb9\xb7\x74\xa9\xbc\x5b\x83\xa9\x80\x10\x00\x2e\xc0\x09\x00\x00\x01\x01\x08\x0a\x28\x2b\x0f\x9e\x05\x77\x1b\xe3"
		ether = Ethernet(s)
		self.failUnless(ether.bin() == s)	# 0xc009
		tcp2 = ether.ip.tcp
		#print(ip_tcp)
		# checksum
		print("sum 1: %s" % tcp2.sum)
		self.failUnless(tcp2.sum == 49161)	# 0xc009
		tcp2.win = 1234
		print("sum 2: %s" % tcp2.sum)
		self.failUnless(tcp2.sum == 47973)
		tcp2.win = 46
		print("sum 3: %s" % tcp2.sum)
		self.failUnless(tcp2.sum == 49161)	# 0xc009
		print("tcp options: %d" % len(tcp2.opts))
		self.failUnless(len(tcp2.opts) == 3)
		self.failUnless(tcp2.opts[2].type == TCP_OPT_TIMESTAMP)
		self.failUnless(tcp2.opts[2].len == 10)
		self.failUnless(tcp2.opts[2].data == b"(+\x0f\x9e\x05w\x1b\xe3")

		# TODO: enable this
		#tcp2.opts[2].append((TCP_OPT_WSCALE, b"\x00\x01"))	# header öength += 4
		for opt in tcp2.opts:
			print(opt)
		#self.failUnless(len(tcp2.opts) == 4)
		#self.failUnless(tcp2.opts[3].type == TCP_OPT_WSCALE)
		#self.failUnless(len(tcp2.off) == 4)


class UDPTestCase(unittest.TestCase):
	def test_UDP(self):
		print(">>>>>>>>> UDP <<<<<<<<<")
		# UDP without body
		s = b"\x95\x73\x00\x35\x00\x23\x81\x49"
		udp1 = UDP(s)
		# parsing
		self.failUnless(udp1.bin() == s)
		self.failUnless(udp1.sport == 38259)
		self.failUnless(udp1.dport == 53)
		# header field udpate
		sport = 124
		dport = 322
		udp1.sport = sport
		udp1.dport = dport
		self.failUnless(udp1.sport == sport)
		self.failUnless(udp1.dport == dport)
		# TODO: removed option "fieldvalue = None"
		#oldlen = len(udp1)
		#udp1.sport = None
		#self.failUnless(udp1.sport == None)
		## removed 4-byte IP address
		#self.failUnless(oldlen == len(udp1) + 2)
		# UDP without body
		s = b"\x95\x73\x00\x35\x00\x23\x81\x49"
		udp2 = UDP(s)
		# reconstruate ports
		udp1.sport = 38259
		udp1.dport = 53
		self.failUnless(udp1.direction(udp2) == Packet.DIR_SAME)
		# checksum (no IP-layer means no checksum change)
		udp2.sport = 38259
		self.failUnless(udp2.sum == 33097)	# 0x8194
		# IP + UDP + DNS
		s = b"\x45\x00\x00\x37\x19\x6c\x40\x00\x40\x11\x3b\xe2\xc0\xa8\xb2\x15\xc0\xa8\xb2\x01" + s + b"\x59\xa2\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x06\x67\x6f\x6f\x67\x6c\x65\x02\x64\x65\x00\x00\x01\x00\x01"
		ip_udp = IP(s)
		self.failUnless(ip_udp.bin() == s)
		print(ip_udp)
		print(ip_udp.udp)
		# checksum
		self.failUnless(ip_udp.udp.sum == 33097)	# 0x8194, sport = 38259
		print("sum 1: %s" % ip_udp.udp.sum)
		ip_udp.udp.sport = 1234
		print("sum 2: %s" % ip_udp.udp.sum)
		self.failUnless(ip_udp.udp.sum == 4587)
		ip_udp.udp.sport = 38259
		print("sum 3: %s" % ip_udp.udp.sum)
		self.failUnless(ip_udp.udp.sum == 33097)
		print(ip_udp)
		print(ip_udp.udp)

class HTTPTestCase(unittest.TestCase):
	def test_HTTP(self):
		print(">>>>>>>>> HTTP <<<<<<<<<")
		# HTTP header + body
		s1 = b"GET / HTTP/1.1\r\nHeader1: value1\r\nHeader2: value2\r\n\r\nThis is the body content\r\n"
		http1 = HTTP(s1)
		self.failUnless(http1.bin() == s1)
		# header changes
		s2 = b"POST / HTTP/1.1\r\nHeader1: value1\r\nHeader2: value2\r\n\r\nThis is the body content\r\n"
		print(">>> new startline POST")
		http1.header[0] = (b"POST / HTTP/1.1",)
		print("http bin: %s" % http1.bin())
		self.failUnless(http1.bin() == s2)
		self.failUnless(http1.header[b"hEaDeR1"][1] == b"value1")
		print(">>> new startline GET")
		http1.header[0] = (b"GET / HTTP/1.1",)
		self.failUnless(http1.bin() == s1)
		s3 = b"GET / HTTP/1.1\r\nHeader1: value1\r\nHeader2: value2\r\n\r\n"
		print(">>> resetting body")
		http1.data = b""
		self.failUnless(http1.bin() == s3)
		# TODO: set ether + ip + tcp + http
		#print("HTTP headers: %s" % http1.headers)

class AccessConcatTestCase(unittest.TestCase):
	def test_concat(self):
		print(">>>>>>>>> CONCAT <<<<<<<<<")
		global BYTES_ETH_IP_TCP_HTTP
		s = BYTES_ETH_IP_TCP_HTTP
		p_all = Ethernet(s)
		print(s)
		print(p_all.bin())
		#print(p_all.padding)
		self.failUnless(p_all.bin() == s)

		eth = Ethernet(BYTES_ETH)
		ip = IP(BYTES_IP)
		tcp = TCP(BYTES_TCP)
		http = HTTP(BYTES_HTTP)

		self.failUnless(type(p_all[Ethernet]) == type(eth))
		self.failUnless(type(p_all[IP]) == type(ip))
		self.failUnless(type(p_all[TCP]) == type(tcp))
		print("type http? %s" % type(p_all[HTTP]))
		self.failUnless(type(p_all[HTTP]) == type(http))

		bytes_concat = [eth.bin(), ip.bin(), tcp.bin(), http.bin()]
		self.failUnless(p_all.bin() == b"".join(bytes_concat))

		p_all_concat = eth + ip + tcp + http
		self.failUnless(p_all.bin() == p_all_concat.bin())

class ICMPTestCase(unittest.TestCase):
	def test_concat(self):
		print(">>>>>>>>> ICMP <<<<<<<<<")
		global BYTES_ETH_IP_ICMPREQ
		req = BYTES_ETH_IP_ICMPREQ

		eth = Ethernet(req)
		self.failUnless(eth.bin() == req)
		icmp = eth[ICMP]
		#print(str(icmp))
		self.failUnless(icmp.type == 8)
		# type=8, checksum=0xEC66, id=2481
		print("sum 1: %d" % icmp.sum)		# 0xEC66 = 22213
		self.failUnless(icmp.sum == 60518)
		self.failUnless(icmp.seq == 1)
		print("data: %s -> %s" % (type(icmp), icmp.data))
		self.failUnless(icmp.data == BYTES_ETH_IP_ICMPREQ[50:])
		icmp.seq = 2
		print("sum 2: %d" % icmp.sum)
		self.failUnless(icmp.sum == 60517)
		icmp.seq = 1
		print("sum 3: %d" % icmp.sum)
		self.failUnless(icmp.sum == 60518)


class OSPFTestCase(unittest.TestCase):
	def test(self):
		print(">>>>>>>>> OSPF <<<<<<<<<")
		s = b"ABCCDDDDEEEEFFFFGGGGGGGG"
		ospf = OSPF(s)
		self.failUnless(ospf.bin() == s)

class PPPTestCase(unittest.TestCase):
	def test_ppp(self):
		print(">>>>>>>>> PPP <<<<<<<<<")
		s = b"\x21" + BYTES_IP
		ppp = PPP(s)
		self.failUnless(ppp.bin() == s)
		self.failUnless(type(ppp[IP]).__name__ == "IP")

class STPTestCase(unittest.TestCase):
	def test_stp(self):
		print(">>>>>>>>> STP <<<<<<<<<")
		s = b"AABCDEEEEEEEEFFFFGGGGGGGGHHIIJJKKLL"
		stp = STP(s)
		self.failUnless(stp.bin() == s)

class VRRPTestCase(unittest.TestCase):
	def test_vrrp(self):
		print(">>>>>>>>> VRRP <<<<<<<<<")
		s = b"ABCDEFGG"
		vrrp = VRRP(s)
		self.failUnless(vrrp.bin() == s)

class AHTestCase(unittest.TestCase):
	def test_ah(self):
		print(">>>>>>>>> AH <<<<<<<<<")
		s = b"\x06\x0c\x00\x00\x11\x11\x11\x11\x22\x22\x22\x22" + BYTES_TCP
		ah = AH(s)
		self.failUnless(ah.bin() == s)

class IGMPTestCase(unittest.TestCase):
	def test_igmp(self):
		print(">>>>>>>>> IGMP <<<<<<<<<")
		s = b"ABCCDDDD"
		igmp = IGMP(s)
		self.failUnless(igmp.bin() == s)

class IPXTestCase(unittest.TestCase):
	def test_ipx(self):
		print(">>>>>>>>> IPX <<<<<<<<<")
		s = b"AABBCDEEEEEEEEEEEEFFFFFFFFFFFF"
		ipx = IPX(s)
		self.failUnless(ipx.bin() == s)

class PIMTestCase(unittest.TestCase):
	def test_ipx(self):
		print(">>>>>>>>> PIM <<<<<<<<<")
		s = b"ABCC"
		pim = PIM(s)
		self.failUnless(pim.bin() == s)

class DHCPTestCase(unittest.TestCase):
	def test_dhcp(self):
		print(">>>>>>>>> DHCP <<<<<<<<<")
		s = BYTES_UDP_DHCPREQ
		dhcp = UDP(s)
		self.failUnless(s == dhcp.bin())
		print("DHCP type: %s" % type(dhcp[DHCP]).__name__)
		self.failUnless(type(dhcp[DHCP]).__name__ == "DHCP")
		dhcp = dhcp[DHCP]
		self.failUnless(len(dhcp.opts) == 7)
		self.failUnless(dhcp.opts[0].type == 53)
		self.failUnless(dhcp.opts[6].type == 255)

		s = BYTES_UDP_DHCPRESP
		dhcp = UDP(s)
		self.failUnless(s == dhcp.bin())
		self.failUnless(type(dhcp[DHCP]).__name__ == "DHCP")
		dhcp = dhcp[DHCP]
		self.failUnless(len(dhcp.opts) == 12)
		self.failUnless(dhcp.opts[0].type == 53)
		self.failUnless(dhcp.opts[11].type == 255)
		dhcp.opts += [(DHCP_OPT_TCPTTL, b"\x00\x01\x02")]
		print("new TLlen: %d" % len(dhcp.opts))
		self.failUnless(len(dhcp.opts) == 13)


class DNSTestCase(unittest.TestCase):
	def test_requestresponse(self):
		print(">>>>>>>>> DNS <<<<<<<<<")
		s = BYTES_DNS_REQUEST
		eth = Ethernet(s)
		self.failUnless(eth.bin() == s)

		s = BYTES_DNS_RESPONSE
		eth = Ethernet(s)
		self.failUnless(eth.bin() == s)

class NTPTestCase(unittest.TestCase):
	def test_ntp(self):
		print(">>>>>>>>> NTP <<<<<<<<<")
		global BYTES_NTP
		s = BYTES_NTP
		n = UDP(s)
		self.failUnless(s == n.bin())
		n = n[NTP]
		print("NTP flags 1")
		print(n)
		self.failUnless(n.li == ntp.NO_WARNING)
		self.failUnless(n.v == 4)
		self.failUnless(n.mode == ntp.SERVER)
		self.failUnless(n.stratum == 2)
		self.failUnless(n.id == b"\xc1\x02\x04\x02")

		# test get/set functions
		print("NTP flags 2")
		n.li = ntp.ALARM_CONDITION
		n.v = 3
		n.mode = ntp.CLIENT
		self.failUnless(n.li == ntp.ALARM_CONDITION)
		self.failUnless(n.v == 3)
		self.failUnless(n.mode == ntp.CLIENT)


class RIPTestCase(unittest.TestCase):
	def test_rip(self):
		global BYTES_RIP
		s = BYTES_RIP
		print(">>>>>>>>> RIP <<<<<<<<<")
		r = RIP(s)
		self.failUnless(s == r.bin())
		print("amount auth/rte: %d" % len(r.rte_auth))
		self.failUnless(len(r.rte_auth) == 2)

		rte = r.rte_auth[1]
		self.failUnless(rte.family == 2)
		self.failUnless(rte.route_tag == 0)
		self.failUnless(rte.metric == 1)

class SCTPTestCase(unittest.TestCase):
	def test_sctp(self):
		global BYTES_SCTP
		s = BYTES_SCTP
		print(">>>>>>>>> SCTP <<<<<<<<<")
		sct = SCTP(s)
		#print("sctp 1: %s" % sct)
		print("sctp 1: %s" % sct.bin())
		self.failUnless(sct.bin() == s)
		print("sctp sum1: %d" % sct.sum)
		self.failUnless(sct.sum == 817557332)
		sct.sum = -1
		# checksum: should be OK, reset to 0 -> recalculcation leads to original sum
		print("sctp sum2: %d" % sct.sum)
		self.failUnless(sct.sum == 817557332)
		#print("sctp 2: %s" % sct)
		print("output via bin()")
		print("sctp 2: %s" % sct.bin())
		print("checking for equality")
		self.failUnless(sct.bin() == s)

		sct = SCTP(s)
		print(sct)
		self.failUnless(sct.sport == 32836)
		self.failUnless(sct.dport == 80)
		self.failUnless(sct.vtag == 0)
		self.failUnless(len(sct.chunks) == 1)
		self.failUnless(len(sct) == 72)

		chunk = sct.chunks[0]
		self.failUnless(chunk.type == sctp.INIT)
		self.failUnless(chunk.len == 60)
		# test dynamic field
		sct.chunks += [(DATA, 0xff, b"\x00\x01\x02")]
		self.failUnless(len(sct.chunks) == 2)
		self.failUnless(sct.chunks[1].data == b"\x00\x01\x02")
		# öazy init of chunks
		sct2 = SCTP()
		sct2.chunks += [(DATA, 0xff, b"\x00\x01\x02")]
		self.failUnless(len(sct2.chunks) == 1)

class ReaderTestCase(unittest.TestCase):
	def test_reader(self):
		print(">>>>>>>>> READER <<<<<<<<<")
		import os
		print(os.getcwd())
		f = open("tests/packets.pcap", "rb")
		pcap = ppcap.Reader(f)

		cnt = 0
		proto_cnt = { ARP:4,
				TCP:34,
				UDP:4,
				ICMP:7,
				HTTP:12
				}
		for ts, buf in pcap:
			cnt += 1
			#print("%02d TS: %s LEN: %d" % (cnt, ts, len(buf)))
			eth = Ethernet(buf)
			keys = proto_cnt.keys()

			for k in keys:
				if eth[k] is not None:
					proto_cnt[k] -= 1
					#if k == HTTP:
					#	print("found HTTP at: %d" % cnt)
					#break

			#try:
			## skip packets out of stream
			#	if not ether_old.direction(ether):
			#	continue
			#except:
			#continue
			#ether_old = ether
			#print("%s:%s -> %s:%s", (ether[IP].src, ether[TCP].src, ether[IP].dst, ether[IP].dst))

			#if http.method == "GET":
			#	print("got GET-request for: %s", % http.uri)

		self.failUnless(cnt == 49)

		print("proto summary:")
		for k,v in proto_cnt.items():
			print("%s: %s" % (k.__name__, v))
			self.failUnless(v == 0)

class PerfTestCase(unittest.TestCase):
	def test_perf(self):
		# IP + ICMP
		s = b"E\x00\x00T\xc2\xf3\x00\x00\xff\x01\xe2\x18\n\x00\x01\x92\n\x00\x01\x0b\x08\x00\xfc\x11:g\x00\x00A,\xc66\x00\x0e\xcf\x12\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f!"#$%&\'()*+,-./01234567"
		cnt = 10000
		print(">>>>>>>>> Performance Tests <<<<<<<<<")
		print("nr = new results on this machine")
		print("or = original results (Intel QuadCore @ 2,2 GHz, 4GB RAM, Python v3.2)")
		print("rounds per test: %d" % cnt)
		print("=====================================")

		print(">>> parsing (IP + ICMP)")
		start = time.time()
		for i in range(cnt):
			ip = IP(s)
		print("time diff: %ss" % (time.time() - start))
		print("nr = %d pps" % (cnt / (time.time() - start)) )
		print("or = 12638 pps")

		print(">>> creating/direct assigning (IP + data)")
		start = time.time()
		for i in range(cnt):
			#ip = IP(src="1.2.3.4", dst="1.2.3.5").bin()
			IP(src=b"\x01\x02\x03\x04", dst=b"\x05\x06\x07\x08", p=17, len=1234, data=b"abcd")
			#ip = IP(src=b"\x01\x02\x03\x04", dst=b"\x05\x06\x07\x08", p=17, len=1234, data=b"abcd")
		print("time diff: %ss" % (time.time() - start))
		print("nr = %d pps" % (cnt / (time.time() - start)) )
		print("or = 31727 pps")

		print(">>> output without change (IP)")
		ip = IP(src=b"\x01\x02\x03\x04", dst=b"\x05\x06\x07\x08", p=17, len=1234, data=b"abcd")
		start = time.time()
		for i in range(cnt):
			ip.bin()
		print("time diff: %ss" % (time.time() - start))
		print("nr = %d pps" % (cnt / (time.time() - start)) )
		print("or = 320996 pps")

		print(">>> output with change/checksum recalculation (IP)")
		ip = IP(src=b"\x01\x02\x03\x04", dst=b"\x05\x06\x07\x08", p=17, len=1234, data=b"abcd")
		start = time.time()
		for i in range(cnt):
			ip.sum = 0
			ip.bin()
		print("time diff: %ss" % (time.time() - start))
		print("nr = %d pps" % (cnt / (time.time() - start)) )
		print("or = 23699 pps")

		print(">>> parsing (Ethernet + IP + TCP + HTTP)")
		global BYTES_ETH_IP_TCP_HTTP
		start = time.time()
		for i in range(cnt):
			eth = Ethernet(BYTES_ETH_IP_TCP_HTTP)
		print("time diff: %ss" % (time.time() - start))
		print("nr = %d pps" % (cnt / (time.time() - start)) )
		print("or = 4137 pps")

		print(">>> changing Triggerlist/binary proto (Ethernet + IP + TCP + HTTP)")
		global BYTES_ETH_IP_TCP_HTTP
		start = time.time()
		eth = Ethernet(BYTES_ETH_IP_TCP_HTTP)
		tcp = eth[TCP]
		for i in range(cnt):
			tcp.opts[0].type = TCP_OPT_WSCALE
		print("time diff: %ss" % (time.time() - start))
		print("nr = %d pps" % (cnt / (time.time() - start)) )
		print("or = 112535 pps")

		print(">>> changing Triggerlist/text based proto (Ethernet + IP + TCP + HTTP)")
		start = time.time()
		eth = Ethernet(BYTES_ETH_IP_TCP_HTTP)
		http = eth[HTTP]
		for i in range(cnt):
			http.header[0] = (b"GET / HTTP/1.1",)
		print("time diff: %ss" % (time.time() - start))
		print("nr = %d pps" % (cnt / (time.time() - start)) )
		print("or = 50449 pps")

		print(">>> concatination (Ethernet + IP + TCP + HTTP)")
		start = time.time()
		for i in range(cnt):
			concat = Ethernet(dst_s="ff:ff:ff:ff:ff:ff", src_s="ff:ff:ff:ff:ff:ff") +\
				IP(src_s="127.0.0.1", dst_s="192.168.0.1") +\
				TCP(sport=1234, dport=123) +\
				HTTP()
		#print("=======================")
		#print(concat)
		print("time diff: %ss" % (time.time() - start))
		print("nr = %d pps" % (cnt / (time.time() - start)) )
		print("or = 7183 pps")


class MetaTest(unittest.TestCase):
	def test_Meta(self):
		pass

class TriggerListHTTPTestCase(unittest.TestCase):
	def test_triggerlist(self):
		print(">>>>>>>>> Triggerlist (via HTTP) <<<<<<<<<")
		hdr = b"GET / HTTP/1.1\r\nkey1: value1\r\nkey2: value2\r\n\r\n"
		tl = HTTPTriggerList(hdr)
		self.failUnless(len(tl) == 3)
		tl += [("key3", "value3")]
		self.failUnless(tl[3][0] == "key3")
		self.failUnless(tl[3][1] == "value3")

class ASN1TestCase(unittest.TestCase):
	def test_asn1(self):
		s = b'0\x82\x02Q\x02\x01\x0bc\x82\x02J\x04xcn=Douglas J Song 1, ou=Information Technology Division, ou=Faculty and Staff, ou=People, o=University of Michigan, c=US\n\x01\x00\n\x01\x03\x02\x01\x00\x02\x01\x00\x01\x01\x00\x87\x0bobjectclass0\x82\x01\xb0\x04\rmemberOfGroup\x04\x03acl\x04\x02cn\x04\x05title\x04\rpostalAddress\x04\x0ftelephoneNumber\x04\x04mail\x04\x06member\x04\thomePhone\x04\x11homePostalAddress\x04\x0bobjectClass\x04\x0bdescription\x04\x18facsimileTelephoneNumber\x04\x05pager\x04\x03uid\x04\x0cuserPassword\x04\x08joinable\x04\x10associatedDomain\x04\x05owner\x04\x0erfc822ErrorsTo\x04\x08ErrorsTo\x04\x10rfc822RequestsTo\x04\nRequestsTo\x04\tmoderator\x04\nlabeledURL\x04\nonVacation\x04\x0fvacationMessage\x04\x05drink\x04\x0elastModifiedBy\x04\x10lastModifiedTime\x04\rmodifiersname\x04\x0fmodifytimestamp\x04\x0ccreatorsname\x04\x0fcreatetimestamp'
		self.failUnless(decode(s) == [(48, [(2, 11), (99, [(4, 'cn=Douglas J Song 1, ou=Information Technology Division, ou=Faculty and Staff, ou=People, o=University of Michigan, c=US'), (10, '\x00'), (10, '\x03'), (2, 0), (2, 0), (1, '\x00'), (135, 'objectclass'), (48, [(4, 'memberOfGroup'), (4, 'acl'), (4, 'cn'), (4, 'title'), (4, 'postalAddress'), (4, 'telephoneNumber'), (4, 'mail'), (4, 'member'), (4, 'homePhone'), (4, 'homePostalAddress'), (4, 'objectClass'), (4, 'description'), (4, 'facsimileTelephoneNumber'), (4, 'pager'), (4, 'uid'), (4, 'userPassword'), (4, 'joinable'), (4, 'associatedDomain'), (4, 'owner'), (4, 'rfc822ErrorsTo'), (4, 'ErrorsTo'), (4, 'rfc822RequestsTo'), (4, 'RequestsTo'), (4, 'moderator'), (4, 'labeledURL'), (4, 'onVacation'), (4, 'vacationMessage'), (4, 'drink'), (4, 'lastModifiedBy'), (4, 'lastModifiedTime'), (4, 'modifiersname'), (4, 'modifytimestamp'), (4, 'creatorsname'), (4, 'createtimestamp')])])])])

class BGPTestCase(unittest.TestCase):
	def testPack(self):
		b1 = BGP(self.bgp1)
		self.failUnless(self.bgp1 == str(b1))
		b2 = BGP(self.bgp2)
		self.failUnless(self.bgp2 == str(b2))
		b3 = BGP(self.bgp3)
		self.failUnless(self.bgp3 == str(b3))
		b4 = BGP(self.bgp4)
		self.failUnless(self.bgp4 == str(b4))

	def testUnpack(self):
		b1 = BGP(self.bgp1)
		self.failUnless(b1.len == 19)
		self.failUnless(b1.type == bgp.KEEPALIVE)
		self.failUnless(b1.keepalive is not None)

		b2 = BGP(self.bgp2)
		self.failUnless(b2.type == bgp.UPDATE)
		self.failUnless(len(b2.update.withdrawn) == 0)
		self.failUnless(len(b2.update.announced) == 1)
		self.failUnless(len(b2.update.attributes) == 9)
		a = b2.update.attributes[1]
		self.failUnless(a.type ==  bgp.AS_PATH)
		self.failUnless(a.len == 10)
		self.failUnless(len(a.as_path.segments) == 2)
		s = a.as_path.segments[0]
		self.failUnless(s.type ==  bgp.AS_SET)
		self.failUnless(s.len == 2)
		self.failUnless(len(s.path) == 2)
		self.failUnless(s.path[0] == 500)

		a = b2.update.attributes[6]
		self.failUnless(a.type == bgp.COMMUNITIES)
		self.failUnless(a.len == 12)
		self.failUnless(len(a.communities.list) == 3)
		c = a.communities.list[0]
		self.failUnless(c.asn == 65215)
		self.failUnless(c.value == 1)
		r = b2.update.announced[0]
		self.failUnless(r.len == 22)
		self.failUnless(r.prefix == b'\xc0\xa8\x04\x00')

		b3 = BGP(self.bgp3)
		self.failUnless(b3.type == bgp.UPDATE)
		self.failUnless(len(b3.update.withdrawn) == 0)
		self.failUnless(len(b3.update.announced) == 0)
		self.failUnless(len(b3.update.attributes) == 6)
		a = b3.update.attributes[0]
		self.failUnless(a.optional == False)
		self.failUnless(a.transitive == True)
		self.failUnless(a.partial == False)
		self.failUnless(a.extended_length == False)
		self.failUnless(a.type == bgp.ORIGIN)
		self.failUnless(a.len == 1)
		o = a.origin
		self.failUnless(o.type == bgp.ORIGIN_IGP)
		a = b3.update.attributes[5]
		self.failUnless(a.optional == True)
		self.failUnless(a.transitive == False)
		self.failUnless(a.partial == False)
		self.failUnless(a.extended_length == True)
		self.failUnless(a.type == bgp.MP_REACH_NLRI)
		self.failUnless(a.len == 30)
		m = a.mp_reach_nlri
		self.failUnless(m.afi == bgp.AFI_IPV4)
		self.failUnless(len(m.snpas) == 0)
		self.failUnless(len(m.announced) == 1)
		p = m.announced[0]
		self.failUnless(p.len == 96)

		b4 = BGP(self.bgp4)
		self.failUnless(b4.len == 45)
		self.failUnless(b4.type == bgp.OPEN)
		self.failUnless(b4.open.asn == 237)
		self.failUnless(b4.open.param_len == 16)
		self.failUnless(len(b4.open.parameters) == 3)
		p = b4.open.parameters[0]
		self.failUnless(p.type == bgp.CAPABILITY)
		self.failUnless(p.len == 6)
		c = p.capability
		self.failUnless(c.code == bgp.CAP_MULTIPROTOCOL)
		self.failUnless(c.len == 4)
		self.failUnless(c.data == b'\x00\x01\x00\x01')
		c = b4.open.parameters[2].capability
		self.failUnless(c.code == bgp.CAP_ROUTE_REFRESH)
		self.failUnless(c.len == 0)

	bgp1 = b'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x13\x04'
	bgp2 = b'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x63\x02\x00\x00\x00\x48\x40\x01\x01\x00\x40\x02\x0a\x01\x02\x01\xf4\x01\xf4\x02\x01\xfe\xbb\x40\x03\x04\xc0\xa8\x00\x0f\x40\x05\x04\x00\x00\x00\x64\x40\x06\x00\xc0\x07\x06\xfe\xba\xc0\xa8\x00\x0a\xc0\x08\x0c\xfe\xbf\x00\x01\x03\x16\x00\x04\x01\x54\x00\xfa\x80\x09\x04\xc0\xa8\x00\x0f\x80\x0a\x04\xc0\xa8\x00\xfa\x16\xc0\xa8\x04'
	bgp3 = b'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x79\x02\x00\x00\x00\x62\x40\x01\x01\x00\x40\x02\x00\x40\x05\x04\x00\x00\x00\x64\xc0\x10\x08\x00\x02\x01\x2c\x00\x00\x01\x2c\xc0\x80\x24\x00\x00\xfd\xe9\x40\x01\x01\x00\x40\x02\x04\x02\x01\x15\xb3\x40\x05\x04\x00\x00\x00\x2c\x80\x09\x04\x16\x05\x05\x05\x80\x0a\x04\x16\x05\x05\x05\x90\x0e\x00\x1e\x00\x01\x80\x0c\x00\x00\x00\x00\x00\x00\x00\x00\x0c\x04\x04\x04\x00\x60\x18\x77\x01\x00\x00\x01\xf4\x00\x00\x01\xf4\x85'
	bgp4 = b'\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x2d\x01\x04\x00\xed\x00\x5a\xc6\x6e\x83\x7d\x10\x02\x06\x01\x04\x00\x01\x00\x01\x02\x02\x80\x00\x02\x02\x02\x00'

class DiameterTestCase(unittest.TestCase):
	def testPack(self):
		d = Diameter(self.s)
		self.failUnless(self.s == str(d))
		d = Diameter(self.t)
		self.failUnless(self.t == str(d))

	def testUnpack(self):
		d = Diameter(self.s)
		self.failUnless(d.len == 40)
		#self.failUnless(d.cmd == DEVICE_WATCHDOG_REQUEST)
		self.failUnless(d.request_flag == 1)
		self.failUnless(d.error_flag == 0)
		self.failUnless(len(d.avps) == 2)

		avp = d.avps[0]
		#self.failUnless(avp.code == ORIGIN_HOST)
		self.failUnless(avp.mandatory_flag == 1)
		self.failUnless(avp.vendor_flag == 0)
		self.failUnless(avp.len == 12)
		self.failUnless(len(avp) == 12)
		self.failUnless(avp.data == b'\x68\x30\x30\x32')

		# also test the optional vendor id support
		d = Diameter(self.t)
		self.failUnless(d.len == 44)
		avp = d.avps[0]
		self.failUnless(avp.vendor_flag == 1)
		self.failUnless(avp.len == 16)
		self.failUnless(len(avp) == 16)
		self.failUnless(avp.vendor == 3735928559)
		self.failUnless(avp.data == b'\x68\x30\x30\x32')

	s = b'\x01\x00\x00\x28\x80\x00\x01\x18\x00\x00\x00\x00\x00\x00\x41\xc8\x00\x00\x00\x0c\x00\x00\x01\x08\x40\x00\x00\x0c\x68\x30\x30\x32\x00\x00\x01\x28\x40\x00\x00\x08'
	t = b'\x01\x00\x00\x2c\x80\x00\x01\x18\x00\x00\x00\x00\x00\x00\x41\xc8\x00\x00\x00\x0c\x00\x00\x01\x08\xc0\x00\x00\x10\xde\xad\xbe\xef\x68\x30\x30\x32\x00\x00\x01\x28\x40\x00\x00\x08'



class H225TestCase(unittest.TestCase):
	def testPack(self):
		h = H225(self.s)
		self.failUnless(self.s == str(h))

	def testUnpack(self):
		h = H225(self.s)
		self.failUnless(h.tpkt.v == 3)
		self.failUnless(h.tpkt.rsvd == 0)
		self.failUnless(h.tpkt.len == 1041)
		self.failUnless(h.proto == 8)
		self.failUnless(h.type == h225.SETUP)
		self.failUnless(len(h.data) == 3)

		ie = h.data[0]
		self.failUnless(ie.type == h225.BEARER_CAPABILITY)
		self.failUnless(ie.len == 3)
		ie = h.data[1]
		self.failUnless(ie.type == h225.DISPLAY)
		self.failUnless(ie.len == 14)
		ie = h.data[2]
		self.failUnless(ie.type == h225.USER_TO_USER)
		self.failUnless(ie.len == 1008)

	s = b'\x03\x00\x04\x11\x08\x02\x54\x2b\x05\x04\x03\x88\x93\xa5\x28\x0e\x4a\x6f\x6e\x20\x4f\x62\x65\x72\x68\x65\x69\x64\x65\x00\x7e\x03\xf0\x05\x20\xb8\x06\x00\x08\x91\x4a\x00\x04\x01\x40\x0c\x00\x4a\x00\x6f\x00\x6e\x00\x20\x00\x4f\x00\x62\x00\x65\x00\x72\x00\x68\x00\x65\x00\x69\x00\x64\x00\x65\x22\xc0\x09\x00\x00\x3d\x06\x65\x6b\x69\x67\x61\x00\x00\x14\x32\x2e\x30\x2e\x32\x20\x28\x4f\x50\x41\x4c\x20\x76\x32\x2e\x32\x2e\x32\x29\x00\x00\x00\x01\x40\x15\x00\x74\x00\x63\x00\x70\x00\x24\x00\x68\x00\x33\x00\x32\x00\x33\x00\x2e\x00\x76\x00\x6f\x00\x78\x00\x67\x00\x72\x00\x61\x00\x74\x00\x69\x00\x61\x00\x2e\x00\x6f\x00\x72\x00\x67\x00\x42\x87\x23\x2c\x06\xb8\x00\x6a\x8b\x1d\x0c\xb7\x06\xdb\x11\x9e\xca\x00\x10\xa4\x89\x6d\x6a\x00\xc5\x1d\x80\x04\x07\x00\x0a\x00\x01\x7a\x75\x30\x11\x00\x5e\x88\x1d\x0c\xb7\x06\xdb\x11\x9e\xca\x00\x10\xa4\x89\x6d\x6a\x82\x2b\x0e\x30\x40\x00\x00\x06\x04\x01\x00\x4c\x10\x09\x00\x00\x3d\x0f\x53\x70\x65\x65\x78\x20\x62\x73\x34\x20\x57\x69\x64\x65\x36\x80\x11\x1c\x00\x01\x00\x98\xa0\x26\x41\x13\x8a\x00\x98\xa0\x26\x41\x13\x8b\x26\x00\x00\x64\x0c\x10\x09\x00\x00\x3d\x0f\x53\x70\x65\x65\x78\x20\x62\x73\x34\x20\x57\x69\x64\x65\x36\x80\x0b\x0d\x00\x01\x00\x98\xa0\x26\x41\x13\x8b\x00\x2a\x40\x00\x00\x06\x04\x01\x00\x4c\x10\x09\x00\x00\x3d\x09\x69\x4c\x42\x43\x2d\x31\x33\x6b\x33\x80\x11\x1c\x00\x01\x00\x98\xa0\x26\x41\x13\x8a\x00\x98\xa0\x26\x41\x13\x8b\x20\x00\x00\x65\x0c\x10\x09\x00\x00\x3d\x09\x69\x4c\x42\x43\x2d\x31\x33\x6b\x33\x80\x0b\x0d\x00\x01\x00\x98\xa0\x26\x41\x13\x8b\x00\x20\x40\x00\x00\x06\x04\x01\x00\x4e\x0c\x03\x00\x83\x00\x80\x11\x1c\x00\x01\x00\x98\xa0\x26\x41\x13\x8a\x00\x98\xa0\x26\x41\x13\x8b\x16\x00\x00\x66\x0e\x0c\x03\x00\x83\x00\x80\x0b\x0d\x00\x01\x00\x98\xa0\x26\x41\x13\x8b\x00\x4b\x40\x00\x00\x06\x04\x01\x00\x4c\x10\xb5\x00\x53\x4c\x2a\x02\x00\x00\x00\x00\x00\x40\x01\x00\x00\x40\x01\x02\x00\x08\x00\x00\x00\x00\x00\x31\x00\x01\x00\x40\x1f\x00\x00\x59\x06\x00\x00\x41\x00\x00\x00\x02\x00\x40\x01\x00\x00\x80\x11\x1c\x00\x01\x00\x98\xa0\x26\x41\x13\x8a\x00\x98\xa0\x26\x41\x13\x8b\x41\x00\x00\x67\x0c\x10\xb5\x00\x53\x4c\x2a\x02\x00\x00\x00\x00\x00\x40\x01\x00\x00\x40\x01\x02\x00\x08\x00\x00\x00\x00\x00\x31\x00\x01\x00\x40\x1f\x00\x00\x59\x06\x00\x00\x41\x00\x00\x00\x02\x00\x40\x01\x00\x00\x80\x0b\x0d\x00\x01\x00\x98\xa0\x26\x41\x13\x8b\x00\x32\x40\x00\x00\x06\x04\x01\x00\x4c\x10\x09\x00\x00\x3d\x11\x53\x70\x65\x65\x78\x20\x62\x73\x34\x20\x4e\x61\x72\x72\x6f\x77\x33\x80\x11\x1c\x00\x01\x00\x98\xa0\x26\x41\x13\x8a\x00\x98\xa0\x26\x41\x13\x8b\x28\x00\x00\x68\x0c\x10\x09\x00\x00\x3d\x11\x53\x70\x65\x65\x78\x20\x62\x73\x34\x20\x4e\x61\x72\x72\x6f\x77\x33\x80\x0b\x0d\x00\x01\x00\x98\xa0\x26\x41\x13\x8b\x00\x1d\x40\x00\x00\x06\x04\x01\x00\x4c\x60\x1d\x80\x11\x1c\x00\x01\x00\x98\xa0\x26\x41\x13\x8a\x00\x98\xa0\x26\x41\x13\x8b\x13\x00\x00\x69\x0c\x60\x1d\x80\x0b\x0d\x00\x01\x00\x98\xa0\x26\x41\x13\x8b\x00\x1d\x40\x00\x00\x06\x04\x01\x00\x4c\x20\x1d\x80\x11\x1c\x00\x01\x00\x98\xa0\x26\x41\x13\x8a\x00\x98\xa0\x26\x41\x13\x8b\x13\x00\x00\x6a\x0c\x20\x1d\x80\x0b\x0d\x00\x01\x00\x98\xa0\x26\x41\x13\x8b\x00\x01\x00\x01\x00\x01\x00\x01\x00\x81\x03\x02\x80\xf8\x02\x70\x01\x06\x00\x08\x81\x75\x00\x0b\x80\x13\x80\x01\xf4\x00\x01\x00\x00\x01\x00\x00\x01\x00\x00\x0c\xc0\x01\x00\x01\x80\x0b\x80\x00\x00\x20\x20\x09\x00\x00\x3d\x0f\x53\x70\x65\x65\x78\x20\x62\x73\x34\x20\x57\x69\x64\x65\x36\x80\x00\x01\x20\x20\x09\x00\x00\x3d\x09\x69\x4c\x42\x43\x2d\x31\x33\x6b\x33\x80\x00\x02\x24\x18\x03\x00\xe6\x00\x80\x00\x03\x20\x20\xb5\x00\x53\x4c\x2a\x02\x00\x00\x00\x00\x00\x40\x01\x00\x00\x40\x01\x02\x00\x08\x00\x00\x00\x00\x00\x31\x00\x01\x00\x40\x1f\x00\x00\x59\x06\x00\x00\x41\x00\x00\x00\x02\x00\x40\x01\x00\x00\x80\x00\x04\x20\x20\x09\x00\x00\x3d\x11\x53\x70\x65\x65\x78\x20\x62\x73\x34\x20\x4e\x61\x72\x72\x6f\x77\x33\x80\x00\x05\x20\xc0\xef\x80\x00\x06\x20\x40\xef\x80\x00\x07\x08\xe0\x03\x51\x00\x80\x01\x00\x80\x00\x08\x08\xd0\x03\x51\x00\x80\x01\x00\x80\x00\x09\x83\x01\x50\x80\x00\x0a\x83\x01\x10\x80\x00\x0b\x83\x01\x40\x00\x80\x01\x03\x06\x00\x00\x00\x01\x00\x02\x00\x03\x00\x04\x00\x05\x00\x06\x01\x00\x07\x00\x08\x00\x00\x09\x01\x00\x0a\x00\x0b\x07\x01\x00\x32\x80\xa6\xff\x4c\x02\x80\x01\x80'


class IEEE80211TestCase(unittest.TestCase):
	def test_802211(self):
		s = b'\xd4\x00\x00\x00\x00\x12\xf0\xb6\x1c\xa4'
		ieee = IEEE80211(s)
		self.failUnless(ieee.version == 0)
		self.failUnless(ieee.type == ieee80211.CTL_TYPE)
		self.failUnless(ieee.subtype == ieee80211.C_ACK)
		self.failUnless(ieee.to_ds == 0)
		self.failUnless(ieee.from_ds == 0)
		self.failUnless(ieee.pwr_mgt == 0)
		self.failUnless(ieee.more_data == 0)
		self.failUnless(ieee.wep == 0)
		self.failUnless(ieee.order == 0)
		self.failUnless(ieee.ack.dst == b'\x00\x12\xf0\xb6\x1c\xa4')

	def test_80211_beacon(self):
		s= b'\x80\x00\x00\x00\xff\xff\xff\xff\xff\xff\x00\x26\xcb\x18\x6a\x30\x00\x26\xcb\x18\x6a\x30\xa0\xd0\x77\x09\x32\x03\x8f\x00\x00\x00\x66\x00\x31\x04\x00\x04\x43\x41\x45\x4e\x01\x08\x82\x84\x8b\x0c\x12\x96\x18\x24\x03\x01\x01\x05\x04\x00\x01\x00\x00\x07\x06\x55\x53\x20\x01\x0b\x1a\x0b\x05\x00\x00\x6e\x00\x00\x2a\x01\x02\x2d\x1a\x6e\x18\x1b\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x30\x14\x01\x00\x00\x0f\xac\x04\x01\x00\x00\x0f\xac\x04\x01\x00\x00\x0f\xac\x01\x28\x00\x32\x04\x30\x48\x60\x6c\x36\x03\x51\x63\x03\x3d\x16\x01\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x85\x1e\x05\x00\x8f\x00\x0f\x00\xff\x03\x59\x00\x63\x73\x65\x2d\x33\x39\x31\x32\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x36\x96\x06\x00\x40\x96\x00\x14\x00\xdd\x18\x00\x50\xf2\x02\x01\x01\x80\x00\x03\xa4\x00\x00\x27\xa4\x00\x00\x42\x43\x5e\x00\x62\x32\x2f\x00\xdd\x06\x00\x40\x96\x01\x01\x04\xdd\x05\x00\x40\x96\x03\x05\xdd\x05\x00\x40\x96\x0b\x09\xdd\x08\x00\x40\x96\x13\x01\x00\x34\x01\xdd\x05\x00\x40\x96\x14\x05'
		ieee = IEEE80211(s)
		self.failUnless(ieee.version == 0)
		self.failUnless(ieee.type == ieee80211.MGMT_TYPE)
		self.failUnless(ieee.subtype == ieee80211.M_BEACON)
		self.failUnless(ieee.to_ds == 0)
		self.failUnless(ieee.from_ds == 0)
		self.failUnless(ieee.pwr_mgt == 0)
		self.failUnless(ieee.more_data == 0)
		self.failUnless(ieee.wep == 0)
		self.failUnless(ieee.order == 0)
		self.failUnless(ieee.mgmt.dst == b'\xff\xff\xff\xff\xff\xff')
		self.failUnless(ieee.mgmt.src == b'\x00\x26\xcb\x18\x6a\x30')
		self.failUnless(ieee.beacon.capability == 0x3104)
		self.failUnless(ieee.capability.privacy == 1)
		self.failUnless(ieee.ssid.data == 'CAEN')
		self.failUnless(ieee.rate.data == b'\x82\x84\x8b\x0c\x12\x96\x18\x24')
		self.failUnless(ieee.ds.data == b'\x01')
		self.failUnless(ieee.tim.data == b'\x00\x01\x00\x00')

	def test_80211_data(self):
		s = b'\x08\x09\x20\x00\x00\x26\xcb\x17\x3d\x91\x00\x16\x44\xb0\xae\xc6\x00\x02\xb3\xd6\x26\x3c\x80\x7e\xaa\xaa\x03\x00\x00\x00\x08\x00\x45\x00\x00\x28\x07\x27\x40\x00\x80\x06\x1d\x39\x8d\xd4\x37\x3d\x3f\xf5\xd1\x69\xc0\x5f\x01\xbb\xb2\xd6\xef\x23\x38\x2b\x4f\x08\x50\x10\x42\x04\xac\x17\x00\x00'
		ieee = IEEE80211(s)
		self.failUnless(ieee.type == ieee80211.DATA_TYPE)
		self.failUnless(ieee.subtype == ieee80211.D_DATA)
		self.failUnless(ieee.data_frame.dst == b'\x00\x02\xb3\xd6\x26\x3c')
		self.failUnless(ieee.data_frame.src == b'\x00\x16\x44\xb0\xae\xc6')
		self.failUnless(ieee.data_frame.frag_seq == 0x807e)
		self.failUnless(ieee.data == b'\xaa\xaa\x03\x00\x00\x00\x08\x00\x45\x00\x00\x28\x07\x27\x40\x00\x80\x06\x1d\x39\x8d\xd4\x37\x3d\x3f\xf5\xd1\x69\xc0\x5f\x01\xbb\xb2\xd6\xef\x23\x38\x2b\x4f\x08\x50\x10\x42\x04\xac\x17\x00\x00')

		llc_pkt = LLC(ieee.data_frame.data)
		ip_pkt = IP(llc_pkt.data)
		self.failUnless(ip_pkt.dst == b'\x3f\xf5\xd1\x69')

	def test_80211_data_qos(self):
		s = b'\x88\x01\x3a\x01\x00\x26\xcb\x17\x44\xf0\x00\x23\xdf\xc9\xc0\x93\x00\x26\xcb\x17\x44\xf0\x20\x7b\x00\x00\xaa\xaa\x03\x00\x00\x00\x88\x8e\x01\x00\x00\x74\x02\x02\x00\x74\x19\x80\x00\x00\x00\x6a\x16\x03\x01\x00\x65\x01\x00\x00\x61\x03\x01\x4b\x4c\xa7\x7e\x27\x61\x6f\x02\x7b\x3c\x72\x39\xe3\x7b\xd7\x43\x59\x91\x7f\xaa\x22\x47\x51\xb6\x88\x9f\x85\x90\x87\x5a\xd1\x13\x20\xe0\x07\x00\x00\x68\xbd\xa4\x13\xb0\xd5\x82\x7e\xc7\xfb\xe7\xcc\xab\x6e\x5d\x5a\x51\x50\xd4\x45\xc5\xa1\x65\x53\xad\xb5\x88\x5b\x00\x1a\x00\x2f\x00\x05\x00\x04\x00\x35\x00\x0a\x00\x09\x00\x03\x00\x08\x00\x33\x00\x39\x00\x16\x00\x15\x00\x14\x01\x00'
		ieee = IEEE80211(s)
		self.failUnless(ieee.type == ieee80211.DATA_TYPE)
		self.failUnless(ieee.subtype == ieee80211.D_QOS_DATA)
		self.failUnless(ieee.data_frame.dst == b'\x00\x26\xcb\x17\x44\xf0')
		self.failUnless(ieee.data_frame.src == b'\x00\x23\xdf\xc9\xc0\x93')
		self.failUnless(ieee.data_frame.frag_seq == 0x207b)
		self.failUnless(ieee.data == b'\xaa\xaa\x03\x00\x00\x00\x88\x8e\x01\x00\x00\x74\x02\x02\x00\x74\x19\x80\x00\x00\x00\x6a\x16\x03\x01\x00\x65\x01\x00\x00\x61\x03\x01\x4b\x4c\xa7\x7e\x27\x61\x6f\x02\x7b\x3c\x72\x39\xe3\x7b\xd7\x43\x59\x91\x7f\xaa\x22\x47\x51\xb6\x88\x9f\x85\x90\x87\x5a\xd1\x13\x20\xe0\x07\x00\x00\x68\xbd\xa4\x13\xb0\xd5\x82\x7e\xc7\xfb\xe7\xcc\xab\x6e\x5d\x5a\x51\x50\xd4\x45\xc5\xa1\x65\x53\xad\xb5\x88\x5b\x00\x1a\x00\x2f\x00\x05\x00\x04\x00\x35\x00\x0a\x00\x09\x00\x03\x00\x08\x00\x33\x00\x39\x00\x16\x00\x15\x00\x14\x01\x00')
		self.failUnless(ieee.qos_data.control == 0x0)

	def test_bug(self):
		s= b'\x88\x41\x2c\x00\x00\x26\xcb\x17\x44\xf0\x00\x1e\x52\x97\x14\x11\x00\x1f\x6d\xe8\x18\x00\xd0\x07\x00\x00\x6f\x00\x00\x20\x00\x00\x00\x00'
		ieee = IEEE80211(s)
		self.failUnless(ieee.wep == 1)

	def test_data_ds(self):
		# verifying the ToDS and FromDS fields and that we're getting the
		# correct values

		s = b'\x08\x03\x00\x00\x01\x0b\x85\x00\x00\x00\x00\x26\xcb\x18\x73\x50\x01\x0b\x85\x00\x00\x00\x00\x89\x00\x26\xcb\x18\x73\x50'
		ieee = IEEE80211(s)
		self.failUnless(ieee.type == ieee80211.DATA_TYPE)
		self.failUnless(ieee.to_ds == 1)
		self.failUnless(ieee.from_ds == 1)
		self.failUnless(ieee.data_frame.sa == b'\x00\x26\xcb\x18\x73\x50')
		self.failUnless(ieee.data_frame.src == b'\x00\x26\xcb\x18\x73\x50')
		self.failUnless(ieee.data_frame.dst == b'\x01\x0b\x85\x00\x00\x00')
		self.failUnless(ieee.data_frame.da == b'\x01\x0b\x85\x00\x00\x00')

		s = b'\x88\x41\x50\x01\x00\x26\xcb\x17\x48\xc1\x00\x24\x2c\xe7\xfe\x8a\xff\xff\xff\xff\xff\xff\x80\xa0\x00\x00\x09\x1a\x00\x20\x00\x00\x00\x00'
		ieee = IEEE80211(s)
		self.failUnless(ieee.type == ieee80211.DATA_TYPE)
		self.failUnless(ieee.to_ds == 1)
		self.failUnless(ieee.from_ds == 0)
		self.failUnless(ieee.data_frame.bssid == b'\x00\x26\xcb\x17\x48\xc1')
		self.failUnless(ieee.data_frame.src == b'\x00\x24\x2c\xe7\xfe\x8a')
		self.failUnless(ieee.data_frame.dst == b'\xff\xff\xff\xff\xff\xff')

		s = b'\x08\x02\x02\x01\x00\x02\x44\xac\x27\x70\x00\x1f\x33\x39\x75\x44\x00\x1f\x33\x39\x75\x44\x90\xa4'
		ieee = IEEE80211(s)
		self.failUnless(ieee.type == ieee80211.DATA_TYPE)
		self.failUnless(ieee.to_ds == 0)
		self.failUnless(ieee.from_ds == 1)
		self.failUnless(ieee.data_frame.bssid == b'\x00\x1f\x33\x39\x75\x44')
		self.failUnless(ieee.data_frame.src == b'\x00\x1f\x33\x39\x75\x44')
		self.failUnless(ieee.data_frame.dst == b'\x00\x02\x44\xac\x27\x70')


class IP6TestCase(unittest.TestCase):

	def test_IP6(self):
		s = b'`\x00\x00\x00\x00(\x06@\xfe\x80\x00\x00\x00\x00\x00\x00\x02\x11$\xff\xfe\x8c\x11\xde\xfe\x80\x00\x00\x00\x00\x00\x00\x02\xb0\xd0\xff\xfe\xe1\x80r\xcd\xca\x00\x16\x04\x84F\xd5\x00\x00\x00\x00\xa0\x02\xff\xff\xf8\t\x00\x00\x02\x04\x05\xa0\x01\x03\x03\x00\x01\x01\x08\n}\x185?\x00\x00\x00\x00'
		ip = IP6(s)
		#print `ip`
		ip.data.sum = 0
		s2 = str(ip)
		ip2 = IP6(s)
		#print `ip2`
		assert(s == s2)

	def test_IP6RoutingHeader(self):
		s = b'`\x00\x00\x00\x00<+@ H\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xde\xca G\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xca\xfe\x06\x04\x00\x02\x00\x00\x00\x00 \x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xde\xca "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xde\xca\x00\x14\x00P\x00\x00\x00\x00\x00\x00\x00\x00P\x02 \x00\x91\x7f\x00\x00'
		ip = IP6(s)
		s2 = str(ip)
		# 43 is Routing header id
		assert(len(ip.extension_hdrs[43].addresses) == 2)
		assert(ip.tcp)
		assert(s == s2)


	def test_IP6FragmentHeader(self):
		s = b'\x06\xee\xff\xfb\x00\x00\xff\xff'
		fh = IP6FragmentHeader(s)
		s2 = str(fh)
		assert(fh.nxt == 6)
		assert(fh.id == 65535)
		assert(fh.frag_off == 8191)
		assert(fh.m_flag == 1)

	def test_IP6OptionsHeader(self):
		s = b';\x04\x01\x02\x00\x00\xc9\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\xc2\x04\x00\x00\x00\x00\x05\x02\x00\x00\x01\x02\x00\x00'
		options = IP6OptsHeader(s).options
		assert(len(options) == 3)

	def test_IP6AHHeader(self):
		s = b';\x04\x00\x00\x02\x02\x02\x02\x01\x01\x01\x01\x78\x78\x78\x78\x78\x78\x78\x78'
		ah = IP6AHHeader(s)
		assert(ah.length == 24)
		assert(ah.auth_data == 'xxxxxxxx')
		assert(ah.spi == 0x2020202)
		assert(ah.seq == 0x1010101)

	def test_IP6ExtensionHeaders(self):
		p = b'`\x00\x00\x00\x00<+@ H\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xde\xca G\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xca\xfe\x06\x04\x00\x02\x00\x00\x00\x00 \x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xde\xca "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xde\xca\x00\x14\x00P\x00\x00\x00\x00\x00\x00\x00\x00P\x02 \x00\x91\x7f\x00\x00'
		ip = IP6(p)

		o = b';\x04\x01\x02\x00\x00\xc9\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\xc2\x04\x00\x00\x00\x00\x05\x02\x00\x00\x01\x02\x00\x00'
		options = IP6HopOptsHeader(o)

		ip.extension_hdrs[0] = options

		fh = b'\x06\xee\xff\xfb\x00\x00\xff\xff'
		ip.extension_hdrs[44] = IP6FragmentHeader(fh)

		ah = b';\x04\x00\x00\x02\x02\x02\x02\x01\x01\x01\x01\x78\x78\x78\x78\x78\x78\x78\x78'
		ip.extension_hdrs[51] = IP6AHHeader(ah)

		do = b';\x02\x01\x02\x00\x00\xc9\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
		ip.extension_hdrs[60] = IP6DstOptsHeader(do)

		assert(len([k for k in ip.extension_hdrs if (not ip.extension_hdrs[k] is None)]) == 5)

	# fix https://code.google.com/p/pypacker/issues/attachmentText?id=59
	def test_IP6DataChecksumFill(self):
		s = b'\x60\x00\x00\x00\x00\x24\x00\x01\xfe\x80\x00\x00\x00\x00\x00\x00\x02\xd0\x09\xff\xfe\xe3\xe8\xde\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x16\x3a\x00\x05\x02\x00\x00\x01\x00\x8f\x00\x74\xfe\x00\x00\x00\x01\x04\x00\x00\x00\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\xff\x98\x06\xe1\x8f\x00\x74\xfe\x00\x00\x00\x01\x04\x00\x00\x00\xff\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\xff\x98\x06\xe1'
		ip = IP6(s)
		origsum = ip.data.sum
		ip.data.sum = 0
		fillsum = str(ip) and ip.data.sum
		assert(fillsum and ip.data.sum == origsum)

class LLCTestCase(unittest.TestCase):

	def test_llc(self):
		s = b'\xaa\xaa\x03\x00\x00\x00\x08\x00\x45\x00\x00\x28\x07\x27\x40\x00\x80\x06\x1d\x39\x8d\xd4\x37\x3d\x3f\xf5\xd1\x69\xc0\x5f\x01\xbb\xb2\xd6\xef\x23\x38\x2b\x4f\x08\x50\x10\x42\x04\xac\x17\x00\x00'

		llc_pkt = LLC(s)
		ip_pkt = IP(llc_pkt.data)
		self.failUnless(llc_pkt.type == ethernet.ETH_TYPE_IP)
		self.failUnless(ip_pkt.dst == b'\x3f\xf5\xd1\x69')


class LLDPTestCase():
# TODO: not yet implemented
#class LLDPTestCase(unittest.TestCase):
	# TODO:XXX more test cases

	def test_lldp(self):
		data = b'\x02\x11\x07' + b"deadbeefcafecafe" \
			   b'\x04\x05\x07' + b"0008" \
			   b'\x06\x02\x00\x3c' \
			   b'\x00\x00'
		lldp = LLDP(data)
		if (data != lldp.pack()):
			raise pypacker.PackError

	def test_eth_lldp(self):
		data = b'\x80\x48\x00\x00\x00\x00' \
			  b'\x80\x48\x00\x00\x00\x00' \
			  b'\x88\xcc' \
			  b'\x02\x11\x07' + b"deadbeefcafecafe" \
			  b'\x04\x05\x07' + b"0008" \
			  b'\x06\x02\x00\x3c' \
			  b'\x00\x00'
		ethlldp = ethernet.Ethernet(data)
		if (data != ethlldp.pack()):
			raise pypacker.PackError

class NetflowV1TestCase(unittest.TestCase):
	sample_v1 = "\x00\x01\x00\x18gza<B\x00\xfc\x1c$\x93\x08p\xac\x01 W\xc0\xa8c\xf7\n\x00\x02\x01\x00\x03\x00\n\x00\x00\x00\x01\x00\x00\x02(gz7,gz7,\\\x1b\x00P\xac\x01\x11,\x10\x00\x00\x00\x00\x04\x00\x1b\xac\x01\x18S\xac\x18\xd9\xaa\xc0\xa82\x02\x00\x03\x00\x19\x00\x00\x00\x01\x00\x00\x05\xdcgz7|gz7|\xd8\xe3\x00P\xac\x01\x06,\x10\x00\x00\x00\x00\x04\x00\x1b\xac\x01\x14\x18\xac\x18\x8d\xcd\xc0\xa82f\x00\x03\x00\x07\x00\x00\x00\x01\x00\x00\x05\xdcgz7\x90gz7\x90\x8a\x81\x17o\xac\x01\x066\x10\x00\x00\x00\x00\x04\x00\x03\xac\x0f'$\xac\x01\xe5\x1d\xc0\xa82\x06\x00\x04\x00\x1b\x00\x00\x00\x01\x00\x00\x02(gz:8gz:8\xa3Q\x126\xac)\x06\xfd\x18\x00\x00\x00\x00\x04\x00\x1b\xac\x01\x16E\xac#\x17\x8e\xc0\xa82\x06\x00\x03\x00\x1b\x00\x00\x00\x01\x00\x00\x02(gz:Lgz:L\xc9\xff\x00P\xac\x1f\x06\x86\x02\x00\x00\x00\x00\x03\x00\x1b\xac\r\t\xff\xac\x01\x99\x95\xc0\xa82\x06\x00\x04\x00\x1b\x00\x00\x00\x01\x00\x00\x05\xdcgz:Xgz:X\xee9\x00\x17\xac\x01\x06\xde\x10\x00\x00\x00\x00\x04\x00\x03\xac\x0eJ\xd8\xac\x01\xae/\xc0\xa82\x06\x00\x04\x00\x1b\x00\x00\x00\x01\x00\x00\x05\xdcgz:hgz:h\xb3n\x00\x15\xac\x01\x06\x81\x10\x00\x00\x00\x00\x04\x00\x1b\xac\x01#8\xac\x01\xd9*\xc0\xa82\x06\x00\x03\x00\x1b\x00\x00\x00\x01\x00\x00\x05\xdcgz:tgz:t\x00\x00\x83P\xac!\x01\xab\x10\x00\x00\x00\x00\x03\x00\x1b\xac\n`7\xac*\x93J\xc0\xa82\x06\x00\x04\x00\x1b\x00\x00\x00\x01\x00\x00\x05\xdcgz:tgz:t\x00\x00\x00\x00\xac\x012\xa9\x10\x00\x00\x00\x00\x04\x00\x07\xac\nG\x1f\xac\x01\xfdJ\xc0\xa82\x06\x00\x04\x00\x1b\x00\x00\x00\x01\x00\x00\x00(gz:\x88gz:\x88!\x99i\x87\xac\x1e\x06~\x02\x00\x00\x00\x00\x03\x00\x1b\xac\x01(\xc9\xac\x01B\xc4\xc0\xa82\x02\x00\x03\x00\x19\x00\x00\x00\x01\x00\x00\x00(gz:\x88gz:\x88}6\x00P\xac\x01\x06\xfe\x10\x00\x00\x00\x00\x04\x00\x1b\xac\x0b\x08\xe8\xac\x01F\xe2\xc0\xa82\x02\x00\x04\x00\x19\x00\x00\x00\x01\x00\x00\x05\xdcgz:\x9cgz:\x9c`ii\x87\xac\x01\x06;\x10\x00\x00\x00\x00\x04\x00\x1b\xac\x01\x1d$\xac<\xf0\xc3\xc0\xa82\x06\x00\x03\x00\x1b\x00\x00\x00\x01\x00\x00\x05\xdcgz:\x9cgz:\x9cF2\x00\x14\xac\x01\x06s\x18\x00\x00\x00\x00\x04\x00\x03\xac\x0b\x11Q\xac\x01\xde\x06\xc0\xa82\x06\x00\x04\x00\x1b\x00\x00\x00\x01\x00\x00\x05\xdcgz:\xb0gz:\xb0\xef#\x1a+\xac)\x06\xe9\x10\x00\x00\x00\x00\x04\x00\x1b\xac\x0cR\xd9\xac\x01o\xe8\xc0\xa82\x02\x00\x04\x00\x19\x00\x00\x00\x01\x00\x00\x05\xdcgz:\xc4gz:\xc4\x13n\x00n\xac\x19\x06\xa8\x10\x00\x00\x00\x00\x03\x00\x19\xac\x01=\xdd\xac\x01}\xee\xc0\xa82f\x00\x03\x00\x07\x00\x00\x00\x01\x00\x00\x00(gz:\xc4gz:\xc4\x00\x00\xdc\xbb\xac\x01\x01\xd3\x10\x00\x00\x00\x00\x04\x00\x1b\xac\x0f(\xd1\xac\x01\xcc\xa5\xc0\xa82\x06\x00\x04\x00\x1b\x00\x00\x00\x01\x00\x00\x05\xdcgz:\xd8gz:\xd8\xc5s\x17o\xac\x19\x06#\x18\x00\x00\x00\x00\x03\x00\x07\xac\n\x85[\xc0\xa8cn\n\x00\x02\x01\x00\x04\x00\n\x00\x00\x00\x01\x00\x00\x05\xdcgz:\xe4gz:\xe4\xbfl\x00P\xac\x01\x06\xcf\x10\x00\x00\x00\x00\x04\x00\x07\xac\x010\x1f\xac\x18!E\xc0\xa82f\x00\x03\x00\x07\x00\x00\x00\x01\x00\x00\x05\xdcgz;\x00gz;\x00\x11\x95\x04\xbe\xc0\xa8\x06\xea\x10\x00\x00\x00\x00\x03\x00\n\xac\x010\xb6\xac\x1e\xf4\xaa\xc0\xa82\x06\x00\x03\x00\x1b\x00\x00\x00\x01\x00\x00\x05\xdcgz;4gz;4\x88d\x00\x17\xac\x01\x06\x1f\x10\x00\x00\x00\x00\x04\x00\x1b\xac\x01#_\xac\x1e\xb0\t\xc0\xa82\x06\x00\x03\x00\x1b\x00\x00\x00\x01\x00\x00\x05\xdcgz;Hgz;H\x81S\x00P\xac \x06N\x10\x00\x00\x00\x00\x03\x00\x1b\xac\x01\x04\xd9\xac\x01\x94c\xc0\xa82\x06\x00\x03\x00\x1b\x00\x00\x00\x01\x00\x00\x02(gz;\\gz;\\U\x10\x00P\xac\x01\x06P\x18\x00\x00\x00\x00\x04\x00\x1b\xac\x01<\xae\xac*\xac!\xc0\xa82\x06\x00\x03\x00\x1b\x00\x00\x00\x01\x00\x00\x00\xfagz;\x84gz;\x84\x0c\xe7\x00P\xac\x01\x11\xfd\x10\x00\x00\x00\x00\x04\x00\x1b\xac\x01\x1f\x1f\xac\x17\xedi\xc0\xa82\x02\x00\x03\x00\x19\x00\x00\x00\x01\x00\x00\x05\xdcgz;\x98gz;\x98\xba\x17\x00\x16\xac\x01\x06|\x10\x00\x00\x00\x00\x03\x00\x07"

	def testPack(self):
		pass

	def testUnpack(self):
		nf = Netflow1(self.sample_v1)
		assert len(nf.data) == 24
		#print repr(nfv1)

class NetflowV5TestCase(unittest.TestCase):
	sample_v5 = b'\x00\x05\x00\x1d\xb5\xfa\xc9\xd0:\x0bAB&Vw\xde\x9bsv1\x00\x01\x00\x00\xac\n\x86\xa6\xac\x01\xaa\xf7\xc0\xa822\x02q\x00i\x00\x00\x00\x01\x00\x00\x02(\xb5\xfa\x81\x14\xb5\xfa\x81\x1452\x00P\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01\x91D\xac\x14C\xe4\xc0\xa82\x16\x00i\x02q\x00\x00\x00\x01\x00\x00\x00(\xb5\xfa\x9b\xbd\xb5\xfa\x9b\xbd\x00P\x85\xd7\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x17\xe2\xd7\xac\x01\x8cV\xc0\xa822\x02q\x00i\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfao\xb8\xb5\xfao\xb8v\xe8\x17o\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x0e\xf2\xe5\xac\x01\x91\xb2\xc0\xa822\x02q\x00i\x00\x00\x00\x01\x00\x00\x00\xfa\xb5\xfa\x81\xee\xb5\xfa\x81\xee\xd0\xeb\x00\x15\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\nCj\xac)\xa7\t\n\x00\x02\x01\x02q\x00\xdb\x00\x00\x00\x01\x00\x00\x02(\xb5\xfa\x85\x92\xb5\xfa\x85\x92\x8c\xb0\x005\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01\x96=\xac\x15\x1a\xa8\xc0\xa82\x16\x00i\x02q\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa\x86\xe0\xb5\xfa\x86\xe0\xb4\xe7\x00\xc2\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01V\xd1\xac\x01\x86\x15\xc0\xa822\x02q\x00i\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa}:\xb5\xfa}:[Q\x00P\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac2\xf1\xb1\xac)\x19\xca\n\x00\x02\x01\x02q\x00\xdb\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa\x83\xc3\xb5\xfa\x83\xc3\x16,\x00\x15\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x0cA4\xac\x01\x9az\xc0\xa822\x02q\x00i\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa\x8d\xa7\xb5\xfa\x8d\xa7\x173\x00\x15\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x1e\xd2\x84\xac)\xd8\xd2\n\x00\x02\x01\x02q\x00\xdb\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa\x8e\x97\xb5\xfa\x8e\x977*\x17o\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01\x85J\xac \x11\xfc\xc0\xa82\x16\x00i\x02q\x00\x00\x00\x01\x00\x00\x02(\xb5\xfa\x884\xb5\xfa\x884\xf5\xdd\x00\x8f\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01\x04\x80\xac<[n\n\x00\x02\x01\x02q\x00\xdb\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa\x9dr\xb5\xfa\x9drs$\x00\x16\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01\xb9J\xac"\xc9\xd7\xc0\xa82\x16\x00i\x02q\x00\x00\x00\x01\x00\x00\x00(\xb5\xfa\x90r\xb5\xfa\x90r\x0f\x8d\x00\xc2\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac*\xa3\x10\xac\x01\xb4\x19\xc0\xa822\x02q\x00i\x00\x00\x00\x01\x00\x00\x00(\xb5\xfa\x92\x03\xb5\xfa\x92\x03pf\x00\x15\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01\xabo\xac\x1e\x7fi\xc0\xa82\x16\x00i\x02q\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa\x93\x7f\xb5\xfa\x93\x7f\x00P\x0b\x98\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x0c\n\xea\xac\x01\xa1\x15\xc0\xa822\x02q\x00i\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfay\xcf\xb5\xfay\xcf[3\x17\xe0\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01\xbb\xb3\xac)u\x8c\n\x00\x02\x01\x00i\x00\xdb\x00\x00\x00\x01\x00\x00\x00\xfa\xb5\xfa\x943\xb5\xfa\x943\x00P\x1e\xca\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x0fJ`\xac\x01\xab\x94\xc0\xa822\x02q\x00i\x00\x00\x00\x01\x00\x00\x02(\xb5\xfa\x87[\xb5\xfa\x87[\x9a\xd6/\xab\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac*\x0f\x93\xac\x01\xb8\xa3\xc0\xa822\x02q\x00i\x00\x00\x00\x01\x00\x00\x00(\xb5\xfa\x89\xbb\xb5\xfa\x89\xbbn\xe1\x00P\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01\x93\xa1\xac\x16\x80\x0c\xc0\xa82\x16\x00i\x02q\x00\x00\x00\x01\x00\x00\x00(\xb5\xfa\x87&\xb5\xfa\x87&\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01\x83Z\xac\x1fR\xcd\xc0\xa82\x16\x00i\x02q\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa\x90\r\xb5\xfa\x90\r\xf7*\x00\x8a\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x0c\xe0\xad\xac\x01\xa8V\xc0\xa822\x02q\x00i\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa\x9c\xf6\xb5\xfa\x9c\xf6\xe5|\x1a+\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x1e\xccT\xac<x&\n\x00\x02\x01\x02q\x00\xdb\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa\x80\xea\xb5\xfa\x80\xea\x00\x00\x00\x00\x00\x00/\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01\xbb\x18\xac\x01|z\xc0\xa82\x16\x00i\x02q\x00\x00\x00\x01\x00\x00\x00\xfa\xb5\xfa\x88p\xb5\xfa\x88p\x00P\x0b}\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x17\x0er\xac\x01\x8f\xdd\xc0\xa822\x02q\x00i\x00\x00\x00\x01\x00\x00\x02(\xb5\xfa\x89\xf7\xb5\xfa\x89\xf7\r\xf7\x00\x8a\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\n\xbb\x04\xac<\xb0\x15\n\x00\x02\x01\x02q\x00\xdb\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa\x90\xa9\xb5\xfa\x90\xa9\x9c\xd0\x00\x8f\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\nz?\xac)\x03\xc8\n\x00\x02\x01\x02q\x00\xdb\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfaue\xb5\xfaue\xee\xa6\x00P\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac\x01\xb5\x05\xc0\xa8c\x9f\n\x00\x02\x01\x00i\x00\xdb\x00\x00\x00\x01\x00\x00\x05\xdc\xb5\xfa{\xc7\xb5\xfa{\xc7\x00P\x86\xa9\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\xac2\xa5\x1b\xac)0\xbf\n\x00\x02\x01\x02q\x00\xdb\x00\x00\x00\x01\x00\x00\x00\xfa\xb5\xfa\x9bZ\xb5\xfa\x9bZC\xf9\x17\xe0\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00'

	def testPack(self):
		pass

	def testUnpack(self):
		nf = Netflow5(self.sample_v5)
		assert len(nf.data) == 29
		#print repr(nfv5)


class PcapTestCase(unittest.TestCase):
	def test_endian(self):
		be = b'\xa1\xb2\xc3\xd4\x00\x02\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x60\x00\x00\x00\x01'
		le = b'\xd4\xc3\xb2\xa1\x02\x00\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x60\x00\x00\x00\x01\x00\x00\x00'
		befh = FileHdr(be)
		lefh = LEFileHdr(le)
		self.failUnless(befh.linktype == lefh.linktype)


class RadiotapTestCase(unittest.TestCase):
	def test_Radiotap(self):
		s = b'\x00\x00\x00\x18\x6e\x48\x00\x00\x00\x02\x6c\x09\xa0\x00\xa8\x81\x02\x00\x00\x00\x00\x00\x00\x00'
		rad = Radiotap(s)
		self.failUnless(rad.version == 0)
		self.failUnless(rad.present_flags == 0x6e480000)
		self.failUnless(rad.tsft_present == 0)
		self.failUnless(rad.flags_present == 1)
		self.failUnless(rad.rate_present == 1)
		self.failUnless(rad.channel_present == 1)
		self.failUnless(rad.fhss_present == 0)
		self.failUnless(rad.ant_sig_present == 1)
		self.failUnless(rad.ant_noise_present == 1)
		self.failUnless(rad.lock_qual_present == 0)
		self.failUnless(rad.db_tx_attn_present == 0)
		self.failUnless(rad.dbm_tx_power_present == 0)
		self.failUnless(rad.ant_present == 1)
		self.failUnless(rad.db_ant_sig_present == 0)
		self.failUnless(rad.db_ant_noise_present == 0)
		self.failUnless(rad.rx_flags_present == 1)
		self.failUnless(rad.channel.freq == 0x6c09)
		self.failUnless(rad.channel.flags == 0xa000)
		self.failUnless(len(rad.fields) == 7)

class TelnetTestCase(unittest.TestCase):
	def test_telnet(self):
		l = []
		s = b"\xff\xfb%\xff\xfa%\x00\x00\x00\xff\xf0\xff\xfd&\xff\xfa&\x05\xff\xf0\xff\xfa&\x01\x01\x02\xff\xf0\xff\xfb\x18\xff\xfb \xff\xfb#\xff\xfb'\xff\xfc$\xff\xfa \x0038400,38400\xff\xf0\xff\xfa#\x00doughboy.citi.umich.edu:0.0\xff\xf0\xff\xfa'\x00\x00DISPLAY\x01doughboy.citi.umich.edu:0.0\x00USER\x01dugsong\xff\xf0\xff\xfa\x18\x00XTERM\xff\xf0\xff\xfd\x03\xff\xfc\x01\xff\xfb\x1f\xff\xfa\x1f\x00P\x00(\xff\xf0\xff\xfd\x05\xff\xfb!\xff\xfd\x01fugly\r\x00yoda\r\x00bashtard\r\x00"
		l.append(s)
		s = b"\xff\xfd\x01\xff\xfd\x03\xff\xfb\x18\xff\xfb\x1f\xff\xfa\x1f\x00X\x002\xff\xf0admin\r\x00\xff\xfa\x18\x00LINUX\xff\xf0foobar\r\x00enable\r\x00foobar\r\x00\r\x00show ip int Vlan 666\r\x00"
		l.append(s)
		s = b"\xff\xfb%\xff\xfa%\x00\x00\x00\xff\xf0\xff\xfd&\xff\xfa&\x05\xff\xf0\xff\xfa&\x01\x01\x02\xff\xf0\xff\xfb&\xff\xfb\x18\xff\xfb \xff\xfb#\xff\xfb\'\xff\xfc$\xff\xfa \x0038400,38400\xff\xf0\xff\xfa#\x00doughboy.citi.umich.edu:0.0\xff\xf0\xff\xfa\'\x00\x00DISPLAY\x01doughboy.citi.umich.edu:0.0\x00USER\x01dugsong\xff\xf0\xff\xfa\x18\x00XTERM\xff\xf0\xff\xfd\x03\xff\xfc\x01\xff\xfb\"\xff\xfa\"\x03\x01\x03\x00\x03b\x03\x04\x02\x0f\x05\x00\xff\xff\x07b\x1c\x08\x02\x04\tB\x1a\n\x02\x7f\x0b\x02\x15\x0c\x02\x17\r\x02\x12\x0e\x02\x16\x0f\x02\x11\x10\x02\x13\x11\x00\xff\xff\x12\x00\xff\xff\xff\xf0\xff\xfb\x1f\xff\xfa\x1f\x00P\x00(\xff\xf0\xff\xfd\x05\xff\xfb!\xff\xfa\"\x01\x0f\xff\xf0\xff\xfd\x01\xff\xfe\x01\xff\xfa\"\x03\x01\x80\x00\xff\xf0\xff\xfd\x01werd\r\n\xff\xfe\x01yoda\r\n\xff\xfd\x01darthvader\r\n\xff\xfe\x01"
		l.append(s)
		exp = [ (['fugly', 'yoda', 'bashtard'], {'USER': 'dugsong', 'DISPLAY': 'doughboy.citi.umich.edu:0.0'}), (['admin', 'foobar', 'enable', 'foobar', '', 'show ip int Vlan 666'], {}), (['werd', 'yoda', 'darthvader'], {'USER': 'dugsong', 'DISPLAY': 'doughboy.citi.umich.edu:0.0'}) ]
		self.failUnless(list(map(telnet.strip_options, l)) == exp)


suite = unittest.TestSuite()
loader = unittest.defaultTestLoader

suite.addTests(loader.loadTestsFromTestCase(CreateTestCase))
suite.addTests(loader.loadTestsFromTestCase(EthTestCase))
suite.addTests(loader.loadTestsFromTestCase(IPTestCase))
suite.addTests(loader.loadTestsFromTestCase(TCPTestCase))
suite.addTests(loader.loadTestsFromTestCase(UDPTestCase))
suite.addTests(loader.loadTestsFromTestCase(HTTPTestCase))
suite.addTests(loader.loadTestsFromTestCase(AccessConcatTestCase))
suite.addTests(loader.loadTestsFromTestCase(ICMPTestCase))
suite.addTests(loader.loadTestsFromTestCase(OSPFTestCase))
suite.addTests(loader.loadTestsFromTestCase(PPPTestCase))
suite.addTests(loader.loadTestsFromTestCase(STPTestCase))
suite.addTests(loader.loadTestsFromTestCase(VRRPTestCase))
suite.addTests(loader.loadTestsFromTestCase(AHTestCase))
suite.addTests(loader.loadTestsFromTestCase(IGMPTestCase))
suite.addTests(loader.loadTestsFromTestCase(IPXTestCase))
suite.addTests(loader.loadTestsFromTestCase(PIMTestCase))
suite.addTests(loader.loadTestsFromTestCase(NTPTestCase))
suite.addTests(loader.loadTestsFromTestCase(DHCPTestCase))
suite.addTests(loader.loadTestsFromTestCase(RIPTestCase))
suite.addTests(loader.loadTestsFromTestCase(SCTPTestCase))
suite.addTests(loader.loadTestsFromTestCase(ReaderTestCase))
#suite.addTests(loader.loadTestsFromTestCase())
#suite.addTests(loader.loadTestsFromTestCase())
#suite.addTests(loader.loadTestsFromTestCase())
#suite.addTests(loader.loadTestsFromTestCase())
#suite.addTests(loader.loadTestsFromTestCase())
#suite.addTests(loader.loadTestsFromTestCase())
suite.addTests(loader.loadTestsFromTestCase(TriggerListHTTPTestCase))
suite.addTests(loader.loadTestsFromTestCase(PerfTestCase))
#suite.addTests(loader.loadTestsFromTestCase(MetaTest))


# TODO: use bytes.fromhex('f0 f1f2  ') -> b'\xf0\xf1\xf2'
#print(ieee80211)
#print(dir(ieee80211))
#print(dir(IEEE80211))
#print(ieee80211.XYZ)

unittest.TextTestRunner().run(suite)
